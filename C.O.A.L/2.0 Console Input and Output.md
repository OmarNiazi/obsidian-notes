The approach for Console input and output used by us is the $ReadConsoleA$ and $WriteConsoleA$ along with the $GetStdHandle$ processes.
Let's first dive deep into the $Invoke$ keyword.

#### Invoke 
It's a directive in MASM that first pushes all the arguments onto the stack from right to left and then calls the process and also handles the return values for the process.
E.g.
```cpp
WriteConsoleA PROTO a1:DWORD, a2:DWORD, a3:DWORD, a4:DWORD, a5:DWORD

.code
main PROC

	invoke WriteConsoleA, eax, addr of array, sizeof array - 1, addr of bytesWritten, 0
```

Here the arguments a5 to a1 are pushed to the stack in order: a5, a4, a3, a2, a1 and then calls the function.

---
#### Note
When you call Windows API functions using Invoke it returns the value to EAX so it's always modified. Whereas ECX, EDX aren't promised to be kept saved so they may or may not be modified. Rest of the general purpose registers are Call safe and their values are preserved. These registers include: EBX, EDI, ESI, ESP, EBP. Even if the func modifies them, it restores them before returning.

---
#### GetStdHandle
A function to get HANDLE for the different standard stream behaviors:
**Common constants**
- `STD_INPUT_HANDLE = -10` ; stdin
- `STD_OUTPUT_HANDLE = -11` ; stdout
- `STD_ERROR_HANDLE = -12` ; stderr

**Return**
- On success: a `HANDLE` (32-bit DWORD) to the requested standard device.
- On failure: returns `INVALID_HANDLE_VALUE` (which is usually `-1` / `0xFFFFFFFF`). Call `GetLastError()` for more details.

**Prototype**
```cpp
GetStdHandle PROTO :DWORD

.code
main PROC
	invoke GetStdHandle, -10 ; input
	invoke GetStdHandle, -11 ; output
	invoke GetStdHandle, -12 ; error (just like cerr)
```

---
### ReadConsoleA
reads user input (characters) directly from a console handle. Blocks until Enter is pressed. Only works if the handle really is a console (not redirected).
Always leaves the input trailed $0Dh$ and $0Ah$

**Their meanings**
- **`0Dh` (decimal 13)** = **Carriage Return (CR)**
    - ASCII control code that moves the “cursor” back to the **start of the current line**.
    - Think of it like: “go back to column 0.”
- **`0Ah` (decimal 10)** = **Line Feed (LF)**
    - ASCII control code that moves the cursor **down one line** but keeps the column.
    - Think of it like: “go one row down.”

Aways reads characters and stores their ASCII values

**Prototype**
```cpp
ReadConsoleA PROTO b1:DWORD, b2:DWORD, b3:DWORD, b4:DWORD, b5:DWORD

.code 
main PROC
	invoke GetStdHandle, -10 ; return value to EAX
	invoke ReadConsoleA, ebx, addr inputBuffer, 4, addr BytesRead, 0
```

- b1: Handle from GetStdHandle. Always returned to EAX
- b2: Address of the memory where the sequence of characters starts
- b3: The length of the whole sequence
- b4: The length of the whole array might be greater than the actual printed chars so this keeps track of number of bytes printed
- b5: Null terminator '\0'

**Output**:
- EAX = nonzero (TRUE) if success, 0 (FALSE) if fail.
        
**Registers**:
- EAX = BOOL (0 or 1) 
- ECX/EDX = trashed    
- EBX/ESI/EDI preserved

---
### WriteConsoleA
writes characters directly to a console handle. Outputs text exactly as-is (no auto newline, no null termination). Only valid for console handles, not files/pipes.
In C++ you could cout integers straight from the memory but this is not possible in MASM. It reads in ASCII characters and writes in ASCII characters. 0908 will output tab space and carriage return respectively and not 908.

It doesn't automatically add in a new line character at the end. You have to manually do it:

```cpp
newline db 0Dh, 0Ah, 0
sizeNewline = ($ - newline)

.code
main PROC
	
	invoke GetStdHandle, -11
	invoke WriteConsoleA, eax, addr newline, sizeNewline, addr bytesWritten, 0

```

**Output**:
- EAX = BOOL (TRUE or FALSE)

**Registers**:
- EAX = success/fail
- ECX/EDX = trashed
- EBX/ESI/EDI preserved

---
## Next
instead of push we can use invoke
[[2.1 Stack]]