# Advanced Floating-Point Processing (The Missing Manual)

## 1. IEEE 754 Representation (The Deep Logic)

You likely know that floating-point numbers have three parts: Sign, Exponent, and Significand (Mantissa). However, the _interaction_ between these parts creates "mind-bending" mathematical edges that standard integers never face.

**The Bias (Why it exists):** The exponent is not stored as a signed integer (e.g., -5 or +5). It is stored as an _unsigned_ integer by adding a **Bias**.

- **REAL4 (Single):** Bias is 127. To represent $2^5$, we store $127 + 5 = 132$ (`10000100b`).
    
- **REAL8 (Double):** Bias is 1023.
    
- **Why?** This allows the CPU to compare floating-point numbers just like integers. Larger exponents look like "larger" unsigned numbers physically in memory, so sorting is faster.
    

**The "Hidden Bit" (Normalized Numbers):** Scientific notation always looks like $1.xxx \times 2^n$. Since the leading "1" is always there for normalized numbers, IEEE 754 _doesn't store it_. It only stores the fractional part ($xxx$).

- **Implication:** A 23-bit mantissa actually gives you 24 bits of precision.
    
- **Edge Case:** If the number is **Zero**, the exponent is 00..00 and the mantissa is 00..00. The "hidden 1" logic is turned off.
    

**Mind-Bending Scenario: Why 0.1 + 0.2 != 0.3** In base 10, $1/10$ is clean (0.1). In base 2, $1/10$ is an infinitely repeating fraction ($0.000110011...$). Since we only have 23 bits (REAL4) to store it, we chop off the infinite tail.

- When you add the chopped "0.1" to the chopped "0.2", the errors accumulate.
    
- The result is something like `0.30000001`.
    
- **Comparison Trap:** Never use `CMP` to check if `MyFloat == 0.3`. Always check if `abs(MyFloat - 0.3) < Epsilon` (a tiny value).
    

## 2. The FPU Stack (Register Mechanics)

The FPU does _not_ use general-purpose registers like EAX or EBX. It has its own private world: a circular stack of eight 80-bit registers named **ST(0)** through **ST(7)**.

**The "Current Top" Concept:** Unlike the system stack (managed by ESP), the FPU stack is managed by a 3-bit pointer in the Status Word field named **TOP**.

- **ST(0)** is always the current Top of Stack.
    
- **ST(1)** is the one below it.
    
- When you `FLD` (load) a value, the TOP pointer decrements (wraps from 0 to 7), and the new value becomes ST(0).
    
- When you `FSTP` (store and pop), the value moves to memory, and the TOP pointer increments.
    

**Edge Case: Stack Overflow (C1 Flag)** If you load (`FLD`) a value when the stack is full (all 8 registers have valid data), the FPU triggers a **Stack Overflow Exception**.

- The result in ST(0) becomes a special value called **Indefinite NaN** (Not a Number).
    
- If you don't handle this exception, your calculation silently turns into "NaN" and infects all subsequent math.
    

## 3. Instruction Mechanics & Synchronization

The x86 CPU and x87 FPU used to be separate chips. Even today, they run somewhat asynchronously.

**The "WAIT" Instruction:** In very old code (8086/80287), if you started an FPU calculation and immediately tried to read the result with the CPU, you would read garbage because the FPU hadn't finished yet. You had to insert `FWAIT` (or `WAIT`).

- **Modern Context:** Today, the CPU automatically checks for FPU errors before executing the _next_ floating-point instruction. However, if your program crashes with an "Unhandled FPU Exception" on a line that looks innocent (like `MOV EAX, 1`), it's often because a _previous_ FPU instruction failed, and the CPU only just noticed.
    

**Loading & Storing (The Variants):**

- **`FLD`**: Loads Real numbers (32/64/80 bit). Pushes to ST(0).
    
- **`FILD`**: Loads **Integers** (16/32/64 bit). Converts them to Floating Point and pushes to ST(0).
    
    - _Usage:_ Critical for mixed-mode math. You can't add an Integer to a Float directly. You must `FILD` the integer first.
        
- **`FISTP`**: Stores ST(0) to memory as an **Integer** and pops.
    
    - _Usage:_ This effectively rounds the float to an int. The rounding method depends on the **RC (Rounding Control)** field in the FPU Control Word.
        

## 4. Comparisons (The "Old vs. New" World)

Comparing floats is annoying because the FPU has its own Condition Code flags (C0, C1, C2, C3), which are totally separate from the CPU's EFLAGS (Zero, Carry, Sign, Overflow).

**The Old Way (Pre-Pentium Pro):** You had to manually move flags from FPU to CPU.

```
fcom  val2      ; Compare ST(0) vs val2. Sets FPU flags C0-C3.
fnstsw ax       ; Store Status Word into AX.
sahf            ; "Store AH into Flags". Moves AH bits to EFLAGS.
je    Label     ; NOW you can jump.
```

**The New Way (FCOMI):** Modern processors support `FCOMI` (Compare and set Integer Flags).

```
fcomi st(0), st(1)  ; Compare and set CPU Zero/Carry/Parity flags directly.
je    Label         ; Just jump!
```

- **Trap:** `FCOMI` only works with registers `ST(n)`, not memory variables.
    

**Edge Case: Unordered Comparison (NaN)** If you compare `5.0` vs `NaN`, is it Greater? Less? Equal?

- **Answer:** None of the above. It is **Unordered**.
    
- The FPU sets **Zero Flag = 1**, **Parity Flag = 1**, and **Carry Flag = 1** (ZPC = 111).
    
- The instruction `JP` (Jump Parity) is often used to check for "Unordered" (NaN) results.
    

## 5. Mixed-Mode Arithmetic & Rounding

One of the most powerful features of the FPU is converting types.

**The Rounding Modes (RC Field):** The FPU Control Word (bits 10-11) dictates how `FISTP` converts a float to an int.

- **00 (Round to Nearest):** The default. 1.5 -> 2, 1.4 -> 1.
    
- **01 (Round Down):** Floor(). 1.9 -> 1.
    
- **10 (Round Up):** Ceil(). 1.1 -> 2.
    
- **11 (Truncate):** Chop off the decimal.
    

**Edge Case: Changing Modes** To implement `floor(x)` in assembly, you often have to:

1. Load the Control Word (`FSTCW`).
    
2. Bitwise OR the bits to set "Round Down".
    
3. Store the Control Word back (`FLDCW`).
    
4. Execute `FISTP`.
    
5. Restore the original Control Word.
    

## 6. MCQs (The Trap Zone)

**1. If ST(0) contains `NaN` and you execute `FADD st(0), 10.0`, what is the result?**

- **Answer:** **NaN**. NaN is infectious. Any operation involving NaN results in NaN.
    

**2. Why is `FILD` (Integer Load) necessary if we have `FLD`?**

- **Answer:** `FLD` assumes the bits at the memory address are _already_ in IEEE format. If you `FLD` a memory slot containing the integer `1` (00000001h), the FPU interprets those bits as a tiny Denormalized float, not the number 1.0. `FILD` performs the conversion logic.
    

**3. What happens if you pop (`FSTP`) when the stack is empty?**

- **Answer:** **Stack Underflow Exception**. The FPU sets the C1 flag (indicating stack fault) and returns an Indefinite NaN.
    

**4. How do you distinguish between "Positive Zero" and "Negative Zero"?**

- **Answer:** You cannot do it with standard comparison instructions (`FCOM`), which treat them as equal. You must examine the raw bits of the number in memory to check the Sign Bit.
    

**5. What is the value of the "Hidden Bit" for a Denormalized number (exponent = 0)?**

- **Answer:** **0**. For denormals, the formula changes to $0.xxx \times 2^{-126}$ (for REAL4). This allows the representation of extremely small numbers close to zero, at the cost of precision.