The stack is a memory part of every program in every language. In assembly we explicitly allocate memory for it at the start by doing:
```cpp
.stack 4096
```

using this we have allocated 4096 bytes of memory to be used as the stack of the program. Stack is a data structure that works on the principle of Last in First out (LIFO).

```mermaid
graph LR
    subgraph Initial["Initial Stack"]
        direction TB
        A1[" "] 
        A2[30]
        A3[20]
        A4[10]
        A1 -.-> A2
        A2 -.-> A3
        A3 -.-> A4
        A4 -.-> A5[Bottom]
    end

    subgraph AfterPush["After PUSH(40)"]
        direction TB
        B1[40]
        B2[30]
        B3[20]
        B4[10]
        B1 -.-> B2
        B2 -.-> B3
        B3 -.-> B4
        B4 -.-> B5[Bottom]
    end

    subgraph AfterPop["After POP()"]
        direction TB
        C1[" "]
        C2[30]
        C3[20]
        C4[10]
        C1 -.-> C2
        C2 -.-> C3
        C3 -.-> C4
        C4 -.-> C5[Bottom]
    end

    Initial -->|"PUSH(40)"| AfterPush
    AfterPush -->|"POP() returns 40"| AfterPop

    style B1 fill:#90EE90
    style A1 fill:#f0f0f0
    style C1 fill:#f0f0f0
    
    style Initial fill:#e1f5ff
    style AfterPush fill:#fff4e1
    style AfterPop fill:#ffe1f5
```

## Concept and Walkthrough
```cpp
; MASM Program - Comprehensive Stack Operations Demo
; Demonstrates all types of data that can be pushed to the stack

.386
.model flat, stdcall
.stack 4096

.data
    myByte      BYTE 42h           ; Byte value
    myWord      WORD 1234h         ; Word value
    myDword     DWORD 12345678h    ; Double word value
    memValue    DWORD 0ABCDh       ; Memory variable
    
.code
main PROC
    ; 1. Push immediate values (constants)
    PUSH 10                        ; Push immediate decimal
    PUSH 0FFh                      ; Push immediate hex
    
    ; 2. Push 16-bit registers
    MOV AX, 5678h
    PUSH AX                        ; Push 16-bit register
    
    ; 3. Push 32-bit registers
    MOV EBX, 11223344h
    PUSH EBX                       ; Push 32-bit register
    
    MOV ECX, 99887766h
    PUSH ECX                       ; Push another 32-bit register
    
    ; 4. Push memory operands
    PUSH myDword                   ; Push DWORD from memory
    PUSH myWord                    ; Push WORD from memory
    
    ; 5. Push EFLAGS register
    PUSHFD                         ; Push 32-bit flags register
    
    ; 6. Push all general purpose registers
    PUSHAD                         ; Push EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI
    
    ; 7. Push segment registers (16-bit)
    PUSH DS                        ; Push data segment
    PUSH ES                        ; Push extra segment
    
    ; Now pop everything back in reverse order
    POP ES
    POP DS
    POPAD                          ; Pop all general purpose registers
    POPFD                          ; Pop flags
    POP myWord
    POP myDword
    POP ECX
    POP EBX
    POP AX
    ADD ESP, 8                     ; Clean up the two immediate values
    
    ; Exit program
    MOV EAX, 0
    RET
main ENDP

END main
```

### Summary
1. Immediate values (8, 16, 32-bit constants)
2. General purpose registers (AX, EAX, EBX, ECX, EDX, ESI, EDI, EBP)
3. Memory operands (BYTE, WORD, DWORD variables)
4. Flags register (PUSHF/PUSHFD for 16/32-bit)
5. All registers at once (PUSHA/PUSHAD for 16/32-bit)
6. Segment registers (CS, DS, ES, SS, FS, GS)

NOTES:
- PUSH always uses word or doubleword operands (2 or 4 bytes)
- Stack grows downward (toward lower memory addresses)
- ESP register automatically decrements with each PUSH
- PUSH of immediate byte values are sign-extended to word/dword

#### Diagram
```mermaid
graph LR
    subgraph S0["Initial State"]
        direction TB
        A0[Empty Stack]
        style A0 fill:#f0f0f0
    end

    subgraph S1["After PUSH 10<br/>PUSH 0FFh"]
        direction TB
        B1[0FFh]
        B2[10]
        B1 -.-> B2
        B2 -.-> B3[Bottom]
    end

    subgraph S2["After PUSH AX<br/>value: 5678h"]
        direction TB
        C1[5678h]
        C2[0FFh]
        C3[10]
        C1 -.-> C2
        C2 -.-> C3
        C3 -.-> C4[Bottom]
    end

    subgraph S3["After PUSH EBX, ECX<br/>EBX=11223344h<br/>ECX=99887766h"]
        direction TB
        D1[99887766h]
        D2[11223344h]
        D3[5678h]
        D4[0FFh]
        D5[10]
        D1 -.-> D2
        D2 -.-> D3
        D3 -.-> D4
        D4 -.-> D5
        D5 -.-> D6[Bottom]
    end

    subgraph S4["After Memory<br/>& Flags Push"]
        direction TB
        E1[EFLAGS]
        E2[myWord]
        E3[myDword]
        E4[99887766h]
        E5[11223344h]
        E6[5678h]
        E7[0FFh]
        E8[10]
        E1 -.-> E2
        E2 -.-> E3
        E3 -.-> E4
        E4 -.-> E5
        E5 -.-> E6
        E6 -.-> E7
        E7 -.-> E8
        E8 -.-> E9[Bottom]
    end

    subgraph S5["After PUSHAD<br/>8 registers"]
        direction TB
        F1[EDI]
        F2[ESI]
        F3[EBP]
        F4[ESP]
        F5[EBX]
        F6[EDX]
        F7[ECX]
        F8[EAX]
        F9[EFLAGS]
        F10[myWord]
        F11[...]
        F1 -.-> F2
        F2 -.-> F3
        F3 -.-> F4
        F4 -.-> F5
        F5 -.-> F6
        F6 -.-> F7
        F7 -.-> F8
        F8 -.-> F9
        F9 -.-> F10
        F10 -.-> F11
    end

    subgraph S6["After Segment<br/>Registers"]
        direction TB
        G1[ES]
        G2[DS]
        G3[EDI]
        G4[ESI]
        G5[EBP]
        G6[ESP]
        G7[EBX]
        G8[EDX]
        G9[ECX]
        G10[EAX]
        G11[...]
        G1 -.-> G2
        G2 -.-> G3
        G3 -.-> G4
        G4 -.-> G5
        G5 -.-> G6
        G6 -.-> G7
        G7 -.-> G8
        G8 -.-> G9
        G9 -.-> G10
        G10 -.-> G11
    end

    S0 -->|"Immediates"| S1
    S1 -->|"16-bit Reg"| S2
    S2 -->|"32-bit Regs"| S3
    S3 -->|"Memory+Flags"| S4
    S4 -->|"PUSHAD"| S5
    S5 -->|"PUSH DS/ES"| S6

    style G1 fill:#90EE90
    style G2 fill:#90EE90
    style F1 fill:#FFD700
    style E1 fill:#87CEEB
```

### POP Walkthrough
```mermaid
graph LR
    subgraph S6["Full Stack"]
        direction TB
        G1[ES]
        G2[DS]
        G3[EDI]
        G4[ESI]
        G5[EBP]
        G6[ESP]
        G7[EBX]
        G8[EDX]
        G9[ECX]
        G10[EAX]
        G11[EFLAGS]
        G12[myWord]
        G13[myDword]
        G14[99887766h]
        G15[11223344h]
        G16[5678h]
        G17[0FFh]
        G18[10]
        G1 -.-> G2
        G2 -.-> G3
        G3 -.-> G4
        G4 -.-> G5
        G5 -.-> G6
        G6 -.-> G7
        G7 -.-> G8
        G8 -.-> G9
        G9 -.-> G10
        G10 -.-> G11
        G11 -.-> G12
        G12 -.-> G13
        G13 -.-> G14
        G14 -.-> G15
        G15 -.-> G16
        G16 -.-> G17
        G17 -.-> G18
        G18 -.-> G19[Bottom]
    end

    subgraph S5["After POP ES<br/>POP DS"]
        direction TB
        F3[EDI]
        F4[ESI]
        F5[EBP]
        F6[ESP]
        F7[EBX]
        F8[EDX]
        F9[ECX]
        F10[EAX]
        F11[EFLAGS]
        F12[myWord]
        F13[myDword]
        F14[99887766h]
        F15[11223344h]
        F16[5678h]
        F17[0FFh]
        F18[10]
        F3 -.-> F4
        F4 -.-> F5
        F5 -.-> F6
        F6 -.-> F7
        F7 -.-> F8
        F8 -.-> F9
        F9 -.-> F10
        F10 -.-> F11
        F11 -.-> F12
        F12 -.-> F13
        F13 -.-> F14
        F14 -.-> F15
        F15 -.-> F16
        F16 -.-> F17
        F17 -.-> F18
        F18 -.-> F19[Bottom]
    end

    subgraph S4["After POPAD<br/>8 registers popped"]
        direction TB
        E1[EFLAGS]
        E2[myWord]
        E3[myDword]
        E4[99887766h]
        E5[11223344h]
        E6[5678h]
        E7[0FFh]
        E8[10]
        E1 -.-> E2
        E2 -.-> E3
        E3 -.-> E4
        E4 -.-> E5
        E5 -.-> E6
        E6 -.-> E7
        E7 -.-> E8
        E8 -.-> E9[Bottom]
    end

    subgraph S3["After POPFD<br/>POP myWord<br/>POP myDword"]
        direction TB
        D1[99887766h]
        D2[11223344h]
        D3[5678h]
        D4[0FFh]
        D5[10]
        D1 -.-> D2
        D2 -.-> D3
        D3 -.-> D4
        D4 -.-> D5
        D5 -.-> D6[Bottom]
    end

    subgraph S2["After POP ECX<br/>POP EBX<br/>POP AX"]
        direction TB
        C1[0FFh]
        C2[10]
        C1 -.-> C2
        C2 -.-> C3[Bottom]
    end

    subgraph S1["After ADD ESP, 8<br/>Clean immediates"]
        direction TB
        A0[Empty Stack]
        style A0 fill:#90EE90
    end

    S6 -->|"POP ES, DS"| S5
    S5 -->|"POPAD"| S4
    S4 -->|"POPFD, POPs"| S3
    S3 -->|"POP Regs"| S2
    S2 -->|"Cleanup"| S1

    style G1 fill:#FFB6C1
    style G2 fill:#FFB6C1
    style F3 fill:#FFD700
    style E1 fill:#87CEEB
    style A0 fill:#90EE90
```

### Push in procedure calling
```cpp
; MASM Program - Function Argument Order Demo
; Function: Subtract(minuend, subtrahend) = minuend - subtrahend
; This demonstrates why argument order matters!

.386
.model flat, stdcall
.stack 4096

.data
    result1 DWORD ?
    result2 DWORD ?
    
.code

; Function: Subtract two numbers
; Parameters: minuend (first), subtrahend (second)
; Returns: minuend - subtrahend in EAX
; Formula: Subtract(10, 3) = 10 - 3 = 7
Subtract PROC
    PUSH EBP                    ; Save base pointer
    MOV EBP, ESP                ; Set up stack frame
    
    ; Stack layout at this point:
    ; [EBP+12] = first parameter (minuend)
    ; [EBP+8]  = second parameter (subtrahend)
    ; [EBP+4]  = return address
    ; [EBP]    = saved EBP
    
    MOV EAX, [EBP+12]          ; Get first parameter (minuend)
    SUB EAX, [EBP+8]           ; Subtract second parameter (subtrahend)
    
    POP EBP                     ; Restore base pointer
    RET 8                       ; Return and clean 8 bytes (2 parameters)
Subtract ENDP

main PROC
    ; ==========================================
    ; CORRECT ORDER: Subtract(10, 3) = 10 - 3 = 7
    ; ==========================================
    PUSH 3                      ; Push subtrahend (second parameter)
    PUSH 10                     ; Push minuend (first parameter)
    CALL Subtract               ; Result in EAX = 7
    MOV result1, EAX            ; Store result (should be 7)
    
    ; ==========================================
    ; WRONG ORDER: Arguments swapped!
    ; We want Subtract(10, 3) but push in wrong order
    ; This gives us Subtract(3, 10) = 3 - 10 = -7
    ; ==========================================
    PUSH 10                     ; Push minuend (WRONG - should be second!)
    PUSH 3                      ; Push subtrahend (WRONG - should be first!)
    CALL Subtract               ; Result in EAX = -7 (WRONG!)
    MOV result2, EAX            ; Store result (will be -7, not 7!)
    
    ; Exit program
    MOV EAX, 0
    RET
main ENDP

END main```
```
EXPLANATION:
; ============
; result1 = 7  (CORRECT: 10 - 3)
; result2 = -7 (WRONG: 3 - 10)
;
; The function expects:
;   [EBP+12] = minuend (number to subtract FROM)
;   [EBP+8]  = subtrahend (number to subtract)
;
; Parameters are pushed RIGHT-TO-LEFT (stdcall convention)
; So for Subtract(10, 3):
;   1. PUSH 3  (second parameter - subtrahend)
;   2. PUSH 10 (first parameter - minuend)
;   3. CALL Subtract
;
; The last pushed value (10) is accessed first as [EBP+12]
; The first pushed value (3) is accessed second as [EBP+8]