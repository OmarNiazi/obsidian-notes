## Introduction to Flags

In x86 assembly (MASM), the **EFLAGS** (32-bit) or **RFLAGS** (64-bit) register is a collection of single-bit flags that store the state of the CPU and the results of recent operations.

These flags are critical for:

1.  **Conditional Logic:** Instructions like `Jxx` (e.g., `JZ`, `JNC`) read these flags to decide whether to jump.
2.  **Arithmetic Status:** They indicate conditions like overflow, a zero result, or a carry-out.
3.  **CPU Control:** They control processor operations, like string instruction direction or interrupt handling.

Flags can be categorized into **Status Flags**, **Control Flags**, and **System Flags**. Our primary focus is on the Status Flags (which are set by most instructions) and the main Control Flag (DF).

-----

## Quick Reference: Flags & VS Debugger

This table summarizes the most common flags, their standard abbreviation, and their representation in the Visual Studio debugger's "Registers" window.

| Flag Name      | Abbr. | VS Debugger |  Type   | Description                                    |
| :------------- | :---: | :---------: | :-----: | :--------------------------------------------- |
| **Overflow**   |  OF   |    `OV`     | Status  | Signed arithmetic overflow occurred.           |
| **Direction**  |  DF   |    `UP`     | Control | String ops decrement (`0`) or increment (`1`). |
| **Interrupt**  |  IF   |    `EI`     | System  | Interrupts Enabled (`1`) or Disabled (`0`).    |
| **Sign**       |  SF   |    `PL`     | Status  | Result is negative (`1`) or positive (`0`).    |
| **Zero**       |  ZF   |    `ZR`     | Status  | Result is zero (`1`) or not zero (`0`).        |
| **Aux. Carry** |  AF   |    `AC`     | Status  | BCD carry from bit 3 to 4.                     |
| **Parity**     |  PF   |    `PE`     | Status  | Parity is even (`1`) or odd (`0`).             |
| **Carry**      |  CF   |    `CY`     | Status  | Unsigned overflow or borrow occurred.          |

-----

## In-Depth Flag Analysis

Below is a detailed breakdown of each major flag, including conventional (indirect) and unconventional (direct) setting methods.

### 1\. Carry Flag (CF)

  * **Abbreviation:** `CF`
  * **VS Debugger:** `CY` 
  * **Description:** The "unsigned overflow" flag. It is also used as a "borrow" flag for subtraction and a bucket for bit-shifting instructions.

#### Conventional Setting (Indirect)

The CF is most commonly set by arithmetic operations.

1.  **`ADD` / `ADC` (Add / Add with Carry):**
      * Set if the unsigned addition results in a value that is too large for the destination operand.
      * `ADC` also *reads* the CF as part of its input.

    ```cpp
    .data
	    val1 BYTE 0FFh ; 255
    .code
	    mov al, val1
	    add al, 1      ; 255 + 1 = 256. Result is 00h. 100000000
	                   ; CF = 1 (unsigned overflow)
	                   ; ZF = 1 (result is zero)

	    mov ax, 0FFFFh
	    add ax, 1      ; 65535 + 1 = 65536. Result is 0000h.
	                   ; CF = 1
    ```

2.  **`SUB` / `SBB` (Subtract / Subtract with Borrow):**
      * Set if an unsigned subtraction requires a "borrow." This happens when subtracting a larger number from a smaller one.
      * `SBB` also *reads* the CF as part of its input.

    ```cpp
    mov al, 5
    sub al, 10     ; 5 - 10 = -5. Unsigned: 5 - 10 requires a borrow.
                   ; Result is 0FBh (-5). 11111011
                   ; CF = 1 (borrow occurred)

    mov al, 10
    sub al, 5      ; 10 - 5 = 5. Result is 5.
                   ; CF = 0 (no borrow)
    ```

3.  **`CMP` (Compare):**
      * `CMP` performs a `SUB` internally but discards the result, only setting flags.
      * `CMP op1, op2` sets `CF=1` if `op1 < op2` (unsigned).

    ```cpp
    mov al, 10
    cmp al, 20     ; Performs 10 - 20. CF = 1.
    jnc is_not_carry ; This jump will NOT be taken

    cmp al, 5      ; Performs 10 - 5. CF = 0.
    jc is_carry    ; This jump will NOT be taken
    ```

4.  **Shift/Rotate Instructions (`SHL`, `SHR`, `RCL`, `RCR`):**

      * The last bit shifted *out* of the operand is copied into the Carry Flag.
      * `RCL` (Rotate Carry Left) and `RCR` (Rotate Carry Right) also rotate the *original* value of CF *into* the operand, creating a 9/17/33/65-bit rotation.

    ```cpp
    mov al, 80h    ; 10000000b
    shl al, 1      ; Shift left. Result is 00000000b.
                   ; The '1' is shifted out.
                   ; CF = 1, ZF = 1

    mov bl, 1      ; 00000001b
    shr bl, 1      ; Shift right. Result is 00000000b.
                   ; The '1' is shifted out.
                   ; CF = 1, ZF = 1
    ```

5.  **`MUL` / `IMUL` (Multiply):**

      * Set if the high-order part of the product is non-zero.
      * For `MUL BL` (8-bit), the result is in `AX`. `CF` is set if `AH` is not 0. AH is non zero
      * For `MUL BX` (16-bit), the result is in `DX:AX`. `CF` is set if `DX` is not 0.

	```cpp
	.code
		mov al, 30
		mov bl, 30
		mul bl ; res in ax = 900 > 255 so ah will be non zero so CF = 1
		
		mov ax, 65535
		mov bx, 2
		mul bx ; CF = 1
	```

#### Direct & Unconventional Setting

1.  **`STC` (Set Carry Flag):**

      * Directly sets `CF = 1`. No other flags are affected.

    ```masm
    stc            ; CF is now 1, unconditionally
    ```

2.  **`CLC` (Clear Carry Flag):**

      * Directly sets `CF = 0`. No other flags are affected.

    ```masm
    clc            ; CF is now 0, unconditionally
    ```

3.  **`CMC` (Complement Carry Flag):**

      * Flips the current value of the Carry Flag (`CF = NOT CF`).

    ```masm
    stc            ; CF = 1
    cmc            ; CF = 0
    cmc            ; CF = 1
    ```

4.  **Bit Test Instructions (`BT`, `BTS`, `BTR`, `BTC`):**

      * These instructions test a specific bit and copy its value into the Carry Flag.
      * `BT`: Bit Test (copies bit to CF)
      * `BTS`: Bit Test and Set (copies bit to CF, then sets the bit to 1)
      * `BTR`: Bit Test and Reset (copies bit to CF, then clears the bit to 0)
      * `BTC`: Bit Test and Complement (copies bit to CF, then flips the bit)

    ```cpp
    .data
    myVal DWORD 00000001b ; Bit 0 is set
    .code
    ; Test bit 0
    bt myVal, 0    ; Copies bit 0 (which is 1) into CF.
                   ; CF = 1

    ; Test bit 1
    bt myVal, 1    ; Copies bit 1 (which is 0) into CF.
                   ; CF = 0

    ; Test bit 0 and set it to 1
    bts myVal, 0   ; CF = 1 (original value)
                   ; myVal is unchanged (still 00000001b)

    ; Test bit 1 and set it to 1
    bts myVal, 1   ; CF = 0 (original value)
                   ; myVal is now 00000011b
    ```

-----

### 2\. Zero Flag (ZF)

  * **Abbreviation:** `ZF`
  * **VS Debugger:** `ZR` 
  * **Description:** Set if the result of an operation is zero. This is one of the most important flags for loops and comparisons.

#### Conventional Setting (Indirect)

1.  **Arithmetic (`ADD`, `SUB`, `INC`, `DEC`, `MUL`, `DIV`):**

      * Set if the *entire result* of the operation is 0.

    ```cpp
    mov al, 1
    dec al         ; 1 - 1 = 0. Result is 0.
                   ; ZF = 1

    mov bx, 0FFFFh
    inc bx         ; FFFFh + 1 = 10000h. Result in BX is 0000h.
                   ; ZF = 1, CF = 1

    mov eax, 5
    sub eax, 5     ; 5 - 5 = 0. Result is 0.
                   ; ZF = 1
    ```

2.  **Logical (`AND`, `OR`, `XOR`):**

      * Set if the result of the bitwise operation is 0.

    ```cpp
    mov al, 10101010b
    mov bl, 01010101b
    and al, bl     ; Result is 00000000b
                   ; ZF = 1
    ```

3.  **`CMP` (Compare):**

      * `CMP op1, op2` performs `op1 - op2`. If `op1 == op2`, the result is 0.
      * This is the primary way to check for equality.

    ```cpp
    mov eax, 100
    cmp eax, 100   ; 100 - 100 = 0.
                   ; ZF = 1
    jz are_equal   ; Jump if Zero (ZF=1) - This jump is taken

    cmp eax, 99    ; 100 - 99 = 1.
                   ; ZF = 0
    jne not_equal  ; Jump if Not Equal (ZF=0) - This jump is taken
    ```

4.  **`TEST` (Logical AND and Set Flags):**

      * `TEST` performs a bitwise `AND` but discards the result, *only* setting flags (primarily ZF, SF, PF).
      * This is the standard way to check if one or more bits are set *without* modifying the operands.

    ```cpp
    mov al, 00001000b ; Bit 3 is set

    ; Check if bit 3 is set
    test al, 00001000b ; 1000b AND 1000b = 1000b. Result is non-zero.
                      ; ZF = 0

    ; Check if bit 0 is set
    test al, 00000001b ; 1000b AND 0001b = 0000b. Result is zero.
                      ; ZF = 1
    ```

#### Direct & Unconventional Setting

1.  **`XOR reg, reg` (The "Zeroing" Idiom):**

      * This is the classic, optimized way to set a register to zero.
      * `XOR EAX, EAX` is faster and smaller than `MOV EAX, 0`.
      * A side effect is that it *always* sets the Zero Flag.

    ```cpp
    xor ecx, ecx   ; ECX is now 0.
                   ; ZF = 1 (because the result is 0)
                   ; CF = 0, OF = 0
    ```

2.  **`TEST reg, reg` (The "Test Self" Idiom):**

      * This is the standard way to check if a register is zero *without* modifying it (unlike `XOR`).
      * It performs `reg AND reg`, which just equals `reg`. The flags are set based on that value.
      * If `EAX` is 0, `TEST EAX, EAX` results in 0, so `ZF = 1`.
      * If `EAX` is non-zero, the result is non-zero, so `ZF = 0`.

    ```cpp
    ; ... some operations ...
    ; Now we check if EAX is zero
    test eax, eax  ; Sets ZF based on whether EAX is 0
    jz eax_was_zero ; Jump if EAX was 0
    ```

3.  **`LOOP` Instructions:**

      * The `LOOP`, `LOOPE`/`LOOPZ`, and `LOOPNE`/`LOOPNZ` instructions are unconventional setters.
      * `LOOP`: Decrements `ECX`. If `ECX != 0`, it jumps. It does *not* use ZF.
      * `LOOPE`/`LOOPZ`: Decrements `ECX`. Jumps if `ECX != 0` **AND** `ZF = 1`.
      * `LOOPNE`/`LOOPNZ`: Decrements `ECX`. Jumps if `ECX != 0` **AND** `ZF = 0`.
      * These instructions *read* ZF but don't *set* it in a conventional way (the internal `DEC ECX` does not affect the flags for the jump condition).

-----

### 3\. Sign Flag (SF)

  * **Abbreviation:** `SF`
  * **VS Debugger:** `PL`
  * **Description:** Set if the result of an operation is negative. It is a direct copy of the **Most Significant Bit (MSB)** of the result.
      * For 8-bit (`AL`): Bit 7
      * For 16-bit (`AX`): Bit 15
      * For 32-bit (`EAX`): Bit 31

#### Conventional Setting (Indirect)

1.  **Arithmetic/Logical Operations:**

      * Any instruction that produces a result will set SF based on that result's MSB.

    ```cpp
    mov al, 0
    sub al, 1      ; 0 - 1 = -1. Result is 0FFh (11111111b).
                   ; MSB is 1.
                   ; SF = 1 

    mov al, 120    ; 01111000b
    add al, 10     ; 120 + 10 = 130 (10000010b).
                   ; MSB is 1.
                   ; SF = 1 
                   ; NOTE: This is a *signed overflow*! (OF=1)
                   ; The result is positive (130) but interpreted as
                   ; negative (-126) if signed.
    ```

2.  **`CMP` (Compare):**

      * `CMP op1, op2` sets `SF` based on the result of `op1 - op2`.
      * `SF` is set if the result is negative.
      * **Warning:** `SF` alone is not enough to determine "less than." For signed comparisons (`JL`, `JGE`), the CPU checks `SF != OF`.

    ```cpp
    mov al, -5     ; 0FBh
    cmp al, 10     ; -5 - 10 = -15. Result is negative.
                   ; SF = 1
    jl is_less     ; This jump (Jump if Less) IS taken.
    ```

3.  **`TEST` (Test):**

      * `TEST` sets `SF` based on the MSB of the `AND` result.

    ```cpp
    mov al, 80h    ; 10000000b
    test al, al    ; 10000000b AND 10000000b = 10000000b
                   ; MSB of result is 1.
                   ; SF = 1 (NG)
    js is_negative ; This jump IS taken
    ```

#### Direct & Unconventional Setting

1.  **Setting SF directly:**

      * There is no `STS` (Set Sign Flag) instruction.
      * You can force it by performing an operation you *know* will result in a negative number.

    ```cpp
    ; Unconventional way to set SF = 1
    or eax, 80000000h  ; Forces the MSB of EAX to 1.
                       ; This sets SF = 1 (unless EAX was 0,
                       ; a complex case).

    ; A more reliable way to just set SF:
    cmp dword ptr [someVar], -1  ; If someVar is > -1
    ; This is contrived. The best way is `POPF`.
    ```

2.  **`POPF` / `POPFD` (Pop Flags):**

      * This is the *true* direct method. You can push the flags, modify the in-memory image, and then pop them back. (See section on this below).

-----

### 4\. Overflow Flag (OF)

  * **Abbreviation:** `OF`
  * **VS Debugger:** `OV` 
  * **Description:** The "signed overflow" flag. It is set if the result of a *signed* arithmetic operation is too large (positive) or too small (negative) to fit in the destination.

**Key Concept:** The CPU detects this by checking the MSBs.

  * **Addition:** `pos + pos = neg` OR `neg + neg = pos`.
  * **Subtraction:** `pos - neg = neg` OR `neg - pos = pos`.

#### Conventional Setting (Indirect)

1.  **`ADD` / `SUB`:**

      * Set when the *sign* of the result is "wrong" for the operation.

    ```cpp
    ; Example 1: Positive Overflow
    mov al, 127    ; 01111111b (Largest 8-bit signed int)
    add al, 1      ; 127 + 1 = 128 (10000000b).
                   ; Result is -128 in signed.
                   ; We added pos + pos and got neg.
                   ; OF = 1 (OV)
                   ; SF = 1 (NG)

    ; Example 2: Negative Overflow
    mov al, -128   ; 10000000b (Smallest 8-bit signed int)
    sub al, 1      ; -128 - 1 = -129.
                   ; Result wraps around to +127 (01111111b).
                   ; We subtracted pos from neg and got pos.
                   ; OF = 1 (OV)
                   ; SF = 0 (PL)
    ```

2.  **`IMUL` (Signed Multiply):**

      * Set if the high-order part of the signed product is not just a *sign extension* of the low-order part.
      * This is simpler than `MUL`'s check: it means the result doesn't fit in the smaller destination.

3.  **`SHL` / `SAL` (Shift Left):**

      * `SHL` and `SAL` are identical.
      * For a 1-bit shift, `OF` is set if the new MSB (sign bit) is different from the original MSB.
      * It is the *only* shift instruction that modifies `OF`. `SHR` and `SAR` do not.

    ```cpp
    mov al, 01000000b ; +64
    shl al, 1      ; Result: 10000000b (-128)
                   ; Sign bit changed from 0 to 1.
                   ; OF = 1
    ```

#### Direct & Unconventional Setting

1.  **`INTO` (Interrupt on Overflow):**

      * This is an *unconventional read*. It does not *set* `OF`.
      * It triggers software interrupt 4 (`INT 4`) *if* `OF = 1`. It does nothing if `OF = 0`. It's rarely used.

2.  **`POPF` / `POPFD`:**

      * The only reliable way to set `OF` directly.

3.  **Logical Operations (`AND`, `OR`, `XOR`, `TEST`):**

      * These instructions **always clear OF = 0**. This is a very common "unconventional" side effect.
      * If you perform an `AND` operation, you can be 100% certain `OF` is 0 afterward.

    ```cpp
    mov al, 127
    add al, 1      ; OF = 1
    test al, al    ; Tests AL. Does not change AL.
                   ; OF = 0 (cleared by TEST)
    ```

-----

### 5\. Parity Flag (PF)

  * **Abbreviation:** `PF`
  * **VS Debugger:** `PE` 
  * **Description:** Set if the **least significant byte (LSB)** of the result contains an *even* number of 1-bits.
  * This flag is a holdover from old hardware error-checking and is rarely used in modern applications.

#### Conventional Setting

  * Set by all standard arithmetic and logical instructions (`ADD`, `SUB`, `AND`, `OR`, `XOR`, `TEST`, `INC`, `DEC`, etc.).

```cpp
mov al, 0
add al, 3      ; Result is 00000011b
               ; Two '1' bits (even).
               ; PF = 1 (PE)

mov al, 0
add al, 7      ; Result is 00000111b
               ; Three '1' bits (odd).
               ; PF = 0 (PO)

mov eax, 0FFFFFFFFh ; 32 '1' bits
test eax, eax       ; Result is FFFFFFFFh.
                    ; LSB is FFh (11111111b)
                    ; Eight '1' bits (even).
                    ; PF = 1 (PE)
```

-----

### 6\. Auxiliary Carry Flag (AF)

  * **Abbreviation:** `AF`
  * **VS Debugger:** `AC` (Aux Carry, 1) / `NA` (No Aux Carry, 0)
  * **Description:** Set if a carry or borrow occurred between **bit 3 and bit 4** of the result.
  * This flag's *only* purpose is for **Binary Coded Decimal (BCD)** arithmetic. BCD stores one decimal digit (0-9) per 4-bit "nibble." `AF` detects overflow from one digit to the next.

#### Conventional Setting

  * Set by `ADD`, `SUB`, `INC`, `DEC`, `CMP`.

```cpp
mov al, 0Fh    ; 00001111b
add al, 1      ; 0Fh + 1 = 10h (00010000b)
               ; A carry occurred from bit 3 (1) to bit 4 (0).
               ; AF = 1 (AC)
```

#### Unconventional Use (Direct)

  * The `AF` flag is *read* by special BCD instructions.
  * **`DAA` (Decimal Adjust after Addition):** Fixes the result in `AL` to be a valid BCD number after an `ADD` or `ADC`. It *uses* `AF` and `CF` to do this.
  * **`DAS` (Decimal Adjust after Subtraction):** Fixes the result in `AL` after a `SUB` or `SBB`.

-----

### 7\. Direction Flag (DF)

  * **Abbreviation:** `DF`
  * **VS Debugger:** `DN` (Down/Decrement, 1) / `UP` (Up/Increment, 0)
  * **Type:** Control Flag (not a Status Flag)
  * **Description:** Controls the direction of string instructions (`MOVSB`/`W`/`D`, `STOSB`, `CMPSB`, `LODSB`, `SCASB`).
      * `DF = 0` (Clear): "Up." Pointers (`ESI`, `EDI`) are incremented.
      * `DF = 1` (Set): "Down." Pointers (`ESI`, `EDI`) are decremented.

#### Conventional Setting (Direct)

`DF` is *never* set indirectly by arithmetic. It is *only* set directly by the programmer.

1.  **`CLD` (Clear Direction Flag):**

      * Sets `DF = 0` (`UP`).
      * This is the standard C/C++ calling convention. You must *always* use `CLD` or ensure `DF=0` before returning from `asm` code that calls C functions.

    <!-- end list -->

    ```masm
    .data
    source BYTE "hello",0
    dest BYTE 6 DUP(?)
    .code
    cld            ; Clear DF. ESI/EDI will increment.
    mov esi, OFFSET source
    mov edi, OFFSET dest
    mov ecx, 6     ; Number of bytes to move
    rep movsb      ; Move string byte (ESI -> EDI)
                   ; ESI and EDI increment each time.
    ```

2.  **`STD` (Set Direction Flag):**

      * Sets `DF = 1` (`DN`).
      * Used for processing strings from end-to-start.

    <!-- end list -->

    ```masm
    .data
    source BYTE "hello",0
    dest BYTE 6 DUP(?)
    .code
    std            ; Set DF. ESI/EDI will decrement.
    mov esi, OFFSET source + 5 ; Point to end of string (null)
    mov edi, OFFSET dest + 5   ; Point to end of dest
    mov ecx, 6
    rep movsb      ; Move string byte (ESI -> EDI)
                   ; ESI and EDI decrement each time.
    ```

-----

## Ultimate Direct Control: PUSHF & POPF

The most "unconventional" and direct way to set *any* flag is to modify the `EFLAGS` register directly. Since you can't `MOV` to/from `EFLAGS`, you use the stack.

  * **`PUSHF`** (16-bit) / **`PUSHFD`** (32-bit) / **`PUSHFQ`** (64-bit): Pushes the entire flags register onto the stack.
  * **`POPF`** / **`POPFD`** / **`POPFQ`**: Pops a value from the stack into the flags register.

You can use this to set any combination of flags at once.

### Example: Forcing ZF=1 and CF=1

The `EFLAGS` bitmasks are:

  * `CF` = Bit 0 (mask `0001h`)
  * `ZF` = Bit 6 (mask `0040h`)

<!-- end list -->

```masm
.code
    pushfd             ; Push current 32-bit EFLAGS onto stack

    ; Now EFLAGS is at [esp]. We want to set bits 0 and 6.
    or dword ptr [esp], 0041h  ; (0040h for ZF + 0001h for CF)
                               ; This sets ZF and CF to 1,
                               ; leaving all other flags as they were.

    ; To *force* a specific pattern (e.g., only ZF=1, CF=1, rest 0):
    ; mov dword ptr [esp], 0041h 
    ; (This is dangerous! Clears IF, DF, etc.)

    popfd              ; Pop modified value back into EFLAGS
    
    ; At this point, ZF=1 and CF=1, regardless of
    ; any previous instructions.
    
    jz  this_jump_is_taken
    jc  this_jump_is_also_taken
```