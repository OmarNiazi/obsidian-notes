No fluff, just a deep dive:
```cpp
.386
.model flat, stdcall
.stack 4096

ExitProcess PROTO, dwExitCode: DWORD

.data
	ary1 db 10h,20h,30h,40h,50h
	ary2 dw 1000h,2000h,3000h,4000h,5000h
	ary3 dd 10000000h,20000000h,30000000h,40000000h,50000000h

.code
main PROC
	mov al, ary1[2]	; 30h
	mov al, ary1 + 2 ; 30h
	mov ebx, OFFSET ary1
	mov al, [ebx + 2] ; 30h

	mov ax, ary2[2] ; 2000h and not 3000h bcz [2] adds 2 bytes to the base address
	mov ax, ary2[2 * 2] ; 3000h bcz [2*2] adds 4 bytes to the base address. Formula is: index * size of data type
	mov ax, ary2 + 2 * 2 ; 3000h
	mov ebx, OFFSET ary2
	mov ax, [ebx + 2 * 2] ; 3000h
	; BUT
	mov ax, [ebx + 1] ; 0010h bcz 1 byte is added to the base address
	; Explaination: 
	; Memory for ary2: 00 10 00 20 00 30 00 40 00 50 00 
	; adding 1 moves from 00 to 10, so ax = 0010h (little endian so 10 is treated as LS Byte)

	mov eax, ary3[2] ; 00001000h and not 00003000h bcz [2] adds 2 bytes to the base address 
	;(same memory explanation as above)
	mov eax, ary3[2 * 4] ; 00003000h bcz [2*4] adds 8 bytes to the base address. Formula is: index * size of data type
	mov eax, ary3 + 2 * 4 ; 00003000h
	mov ebx, OFFSET ary3
	mov eax, [ebx + 2 * 4] ; 00003000h
main ENDP
END main
```

Above explains all the ways to load vars into registers.

#### Align
- `ALIGN BYTE` → align to 1 (no effect)
- `ALIGN WORD` → align to 2
- `ALIGN DWORD` → align to 4
- `ALIGN QWORD` → align to 8
- `ALIGN PARA` → align to 16
- `ALIGN n` → align to _n_, where n must be power of 2 (1, 2, 4, 8, 16, 32, …)

