No fluff, just a deep dive:
```cpp
.386
.model flat, stdcall
.stack 4096

ExitProcess PROTO, dwExitCode: DWORD

.data
	ary1 db 10h,20h,30h,40h,50h
	ary2 dw 1000h,2000h,3000h,4000h,5000h
	ary3 dd 10000000h,20000000h,30000000h,40000000h,50000000h

.code
main PROC
	mov al, ary1[2]	; 30h
	mov al, ary1 + 2 ; 30h
	mov ebx, OFFSET ary1
	mov al, [ebx + 2] ; 30h

	mov ax, ary2[2] ; 2000h and not 3000h bcz [2] adds 2 bytes to the base address
	mov ax, ary2[2 * 2] ; 3000h bcz [2*2] adds 4 bytes to the base address. Formula is: index * size of data type
	mov ax, ary2 + 2 * 2 ; 3000h
	mov ebx, OFFSET ary2
	mov ax, [ebx + 2 * 2] ; 3000h
	; BUT
	mov ax, [ebx + 1] ; 0010h bcz 1 byte is added to the base address
	; Explaination: 
	; Memory for ary2: 00 10 00 20 00 30 00 40 00 50 00 
	; adding 1 moves from 00 to 10, so ax = 0010h (little endian so 10 is treated as LS Byte)

	mov eax, ary3[2] ; 00001000h and not 00003000h bcz [2] adds 2 bytes to the base address 
	;(same memory explanation as above)
	mov eax, ary3[2 * 4] ; 00003000h bcz [2*4] adds 8 bytes to the base address. Formula is: index * size of data type
	mov eax, ary3 + 2 * 4 ; 00003000h
	mov ebx, OFFSET ary3
	mov eax, [ebx + 2 * 4] ; 00003000h
main ENDP
END main
```

Above explains all the ways to load vars into registers.

#### Align
- `ALIGN BYTE` → align to 1 (no effect)
- `ALIGN WORD` → align to 2
- `ALIGN DWORD` → align to 4
- `ALIGN QWORD` → align to 8
- `ALIGN PARA` → align to 16
- `ALIGN n` → align to _n_, where n must be power of 2 (1, 2, 4, 8, 16, 32, …)

##### Basic Code:
```cpp
.386
.model flat, stdcall
.stack 4096

ExitProcess PROTO, dwExitCode: DWORD

.data
	var1 db 1 ; current offset : 0000h
	align byte ; align to byte boundary (No change already aligned wrt byte)
	var2 db 2 ; offset : 0001h
	var3 db 3 ; offset : 0002h

	; Now the offset is 0003h

	align word ; align to word boundary (next multiple of 2: Moves from 0003h -> 0004h)
	var4 dw 4 ; offset : 0004h
	var5 db 5 ; offset : 0006h
	var6 db 6 ; offset : 0007h
	var7 db 7 ; offset : 0008h

	; Now the offset is 0009h

	align dword ; align to dword boundary (next multiple of 4: Moves from 0009h -> 000Ch)
	var8 dd 8 ; offset : 000Ch

	; upto so on
	; we can also use a number n with align such that n is a power of 2: 1, 2, 4, 8, 16,...

.code
main PROC
	
	invoke ExitProcess, 0
	
main ENDP
END main
```

#### PTRs
```cpp
.386
.model flat, stdcall
.stack 4096

ExitProcess PROTO, dwExitCode: DWORD

.data
	ary1 db 10h, 20h, 30h, 40h, 50h
	ary2 dw 1000h, 2000h, 3000h, 4000h, 5000h
	ary3 dd 10000000h, 20000000h, 30000000h, 40000000h, 50000000h

.code
main PROC
	mov eax, offset ary1	
	xor ebx, ebx
	mov bx, WORD PTR [eax]	; 2010h
	; memory ary1: 10 20 30 40 50 
	; accesing ary1 using a WORD pointer gets the first two bytes (10h, 20h) and combines them into a WORD in little-endian order, resulting in 2010h.
	mov ecx, DWORD PTR [eax + 1] ; 50403020h (Same explanation as above)

	; practice urself for ary2 and ary3

	invoke ExitProcess, 0
	
main ENDP
END main
```

#### Pointers
```cpp
.386
.model flat, stdcall
.stack 4096

ExitProcess PROTO, dwExitCode: DWORD

.data
	ary db 10h, 20h, 30h, 40h, 50h
	; aryPtr db ary ; Error: Address of array is in 32 bits
	aryPtr dd ary
	aryPtr2 dd offset ary

	; Both ptrs work the same way

.code
main PROC
	xor eax, eax
	xor ebx, ebx

	mov eax, [aryPtr]
	mov ebx, [aryPtr2]
	mov al, [eax]
	mov bl, [ebx]
	
	; We had to dereference both 2 times because they are pointers to pointers (double pointers)
	
main ENDP
END main
```

```cpp
int main() {
	int arr[] = {1, 2, 3, 5};
	cout<< *arr <<endl; // direct correspodence with loading ary offset and dereferncing it
	cout<< **(&arr) <<endl; // direct correspondence with having a pointer to the pointer so we dereference 2 times
	
	// arr = 0x1000 (arbitrary address in a single pointer)
	// &arr = 0x1000 (same address but in double pointer)
}
```

This is what's happening in MASM code. When it dereferences once we go from *&arr* to *arr* basically. The address is same but a layer of pointers is removed.

