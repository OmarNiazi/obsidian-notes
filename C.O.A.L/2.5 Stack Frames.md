# Advanced Procedures (The Missing Manual)

## 1. Stack Frames (The "Sandwich")

A Stack Frame (or Activation Record) is a dedicated area of the stack allocated for a single procedure call. Think of it as a "context sandwich" that holds everything a function needs to run without messing up the function that called it.

### A. The Visual "Stack Map" (Memorize This!)

The stack grows **downwards** (from High Memory to Low Memory).

```
High Memory (Higher Addresses)
    |-------------------|
    |   Parameter 2     |  [EBP + 12]  (Pushed 1st)
    |-------------------|
    |   Parameter 1     |  [EBP + 8]   (Pushed 2nd)
    |-------------------|
    |   Return Address  |  [EBP + 4]   (Pushed by CALL)
    |-------------------| <--- EBP points here after prologue
    |   Saved Old EBP   |  [EBP + 0]   (Pushed by Prologue)
    |-------------------|
    |   Local Var 1     |  [EBP - 4]
    |-------------------|
    |   Local Var 2     |  [EBP - 8]
    |-------------------| <--- ESP points here (Top of Stack)
Low Memory (Lower Addresses)
```

**Key Rule:**

- **Parameters** are _above_ EBP (Positive offsets: `+8`, `+12`, etc.).
    
- **Local Variables** are _below_ EBP (Negative offsets: `-4`, `-8`, etc.).
    

### B. The Life Cycle of a Stack Frame (Step-by-Step)

Let's trace a call to `AddTwo(10, 20)`.

**1. The Setup (Caller Side)** The caller pushes arguments in reverse order (Right-to-Left).

```
push 20          ; Stack: [20]
push 10          ; Stack: [20, 10]
call AddTwo      ; Pushes Return Addr. Stack: [20, 10, RetAddr]
```

**2. The Prologue (Callee Side)** The function prepares its environment.

```
AddTwo PROC
    push ebp        ; Save caller's base pointer. Stack: [20, 10, RetAddr, OldEBP]
    mov  ebp, esp   ; "Freeze" the frame. EBP now points to OldEBP.
                    ; We use EBP for all access now because ESP moves around.
    sub  esp, 8     ; Reserve 8 bytes for local vars. Stack grows down.
```

**3. Execution & Access** We can now access data safely using `EBP`.

- `[ebp + 8]` is **10** (Param 1).
    
- `[ebp + 12]` is **20** (Param 2).
    
- `[ebp - 4]` is **Local Var 1**.
    

**4. The Epilogue (Cleanup)** We must reverse _exactly_ what we did in the prologue.

```
    mov  esp, ebp   ; Snap ESP back to EBP (instantly freeing local variables).
    pop  ebp        ; Restore caller's EBP. ESP now points to Return Addr.
    ret  8          ; Pop Return Addr to EIP, then add 8 to ESP to remove params.
AddTwo ENDP
```

### C. Complex Example: Mixed Data Sizes

What if variables aren't all 4 bytes (DWORD)? You must calculate offsets carefully.

**C Code:**

```
void MyFunc(int a, short b) {
    char x;
    int y;
}
```

**Assembly Implementation:**

```
MyFunc PROC
    push ebp
    mov  ebp, esp
    sub  esp, 5      ; Reserve 1 byte for 'x' + 4 bytes for 'y' = 5 bytes
    
    ; Accessing Parameters
    ; [ebp + 8]  = a (DWORD, 4 bytes)
    ; [ebp + 12] = b (WORD, 2 bytes) - Note: Pushed as 4 bytes usually due to alignment!
    
    ; Accessing Locals
    ; Let's put 'y' (4 bytes) first to keep alignment clean, but strictly:
    ; x is at [ebp - 1] (BYTE)
    ; y is at [ebp - 5] (DWORD)
    
    mov BYTE PTR [ebp-1], 'A'    ; Assign x
    mov DWORD PTR [ebp-5], 100   ; Assign y
    
    mov esp, ebp
    pop ebp
    ret
MyFunc ENDP
```

_Note: In reality, compilers align the stack to 4 bytes, so `sub esp, 5` might become `sub esp, 8` to keep performance high._

## 2. Calling Conventions (Who cleans the mess?)

Different languages handle stack cleanup differently.

### A. C Calling Convention (`cdecl`)

- **Order:** Arguments pushed **Right-to-Left**.
    
- **Cleanup:** The **CALLER** adds to `ESP` after the function returns.
    
- **Advantage:** Allows variable number of arguments (e.g., `printf`), because the caller knows how many it pushed.
    
- **ASM:**
    
    ```
    push arg2
    push arg1
    call MyProc
    add  esp, 8   ; Caller cleans up
    ```
    

### B. Standard Call (`stdcall`) - Used by Windows API

- **Order:** Arguments pushed **Right-to-Left**.
    
- **Cleanup:** The **CALLEE** cleans up using `RET n`.
    
- **ASM:**
    
    ```
    ; Inside Procedure
    RET 8         ; Pops EIP, then adds 8 to ESP
    ```
    

## 3. The `INVOKE` and `PROTO` Directives

MASM automates the `PUSH`/`CALL` sequence to avoid human error.

- **PROTO:** Declares the function signature (like a header file in C).
    
    ```
    MyProc PROTO, arg1:DWORD, arg2:DWORD
    ```
    
- **INVOKE:** Generates the assembly code to push arguments and call.
    
    ```
    INVOKE MyProc, 10, 20
    ```
    
    _Generates:_
    
    ```
    push 20
    push 10
    call MyProc
    ```
    

## 4. Local Variables (`LOCAL` Directive)

Instead of manually calculating offsets (`[ebp-4]`), use `LOCAL`.

**Syntax:**

```
MyProc PROC
    LOCAL var1:DWORD, var2:BYTE
    ; MASM generates the prologue: push ebp, mov ebp, esp, sub esp, 8
    
    mov var1, 10    ; Becomes: mov DWORD PTR [ebp-4], 10
    ret
MyProc ENDP
```

**Critical Edge Case:** Local variables are **uninitialized** (contain garbage) when created. You must assign them values before reading.

## 5. Recursion

A procedure calling itself. Each call creates a _new_ stack frame.

**Factorial Example (n!):**

```
Factorial PROC
    push ebp
    mov  ebp, esp
    mov  eax, [ebp+8]    ; Get n
    cmp  eax, 0          ; Base case: n == 0?
    ja   L1
    mov  eax, 1          ; Return 1
    jmp  L2

L1: dec  eax
    push eax             ; Push n-1
    call Factorial       ; Recursive call
    mov  ebx, [ebp+8]    ; Get n again
    mul  ebx             ; Result = n * Factorial(n-1)

L2: pop  ebp
    ret  4
Factorial ENDP
```

## 6. MCQs (Test Your Knowledge)

1. **Which register points to the base of the current stack frame?**
    
    - A) ESP
        
    - B) EIP
        
    - C) EBP
        
    - D) ESI
        
    - **Answer:** C
        
2. **In the `stdcall` convention, who removes arguments from the stack?**
    
    - A) The Caller
        
    - B) The Callee
        
    - C) The Operating System
        
    - D) The Assembler
        
    - **Answer:** B (Using `RET n`)
        
3. **What does `RET 8` do?**
    
    - A) Returns to address 8.
        
    - B) Returns, then adds 8 to EBP.
        
    - C) Returns, then adds 8 to ESP.
        
    - D) Returns, then subtracts 8 from ESP.
        
    - **Answer:** C (Pops EIP, then `ESP = ESP + 8`)
        
4. **If `EBP` = 1000h, where is the Return Address stored?**
    
    - A) 1000h
        
    - B) 1004h
        
    - C) 09FCh
        
    - D) 1008h
        
    - **Answer:** B (`[ebp+4]`. `[ebp]` is the old EBP.)
        
5. **Why can't `stdcall` support variable arguments (like `printf`)?**
    
    - A) Because it pushes arguments Left-to-Right.
        
    - B) Because the Callee cleans the stack but doesn't know how many args were pushed.
        
    - C) Because it uses registers instead of stack.
        
    - D) It can support them.
        
    - **Answer:** B
        
6. **What happens to local variables when a procedure returns?**
    
    - A) They are zeroed out.
        
    - B) They are written to the heap.
        
    - C) They are technically "lost" as ESP moves above them, but the data remains in memory until overwritten.
        
    - D) They are popped into registers.
        
    - **Answer:** C
        
7. **Which directive defines a function prototype in MASM?**
    
    - A) `EXTERN`
        
    - B) `INVOKE`
        
    - C) `PROTO`
        
    - D) `PUBLIC`
        
    - **Answer:** C