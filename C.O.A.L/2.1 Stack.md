The stack is a memory part of every program in every language. In assembly we explicitly allocate memory for it at the start by doing:
```cpp
.stack 4096
```

using this we have allocated 4096 bytes of memory to be used as the stack of the program. Stack is a data structure that works on the principle of Last in First out (LIFO).

```mermaid
graph LR
    subgraph Initial["Initial Stack"]
        direction TB
        A1[" "] 
        A2[30]
        A3[20]
        A4[10]
        A1 -.-> A2
        A2 -.-> A3
        A3 -.-> A4
        A4 -.-> A5[Bottom]
    end

    subgraph AfterPush["After PUSH(40)"]
        direction TB
        B1[40]
        B2[30]
        B3[20]
        B4[10]
        B1 -.-> B2
        B2 -.-> B3
        B3 -.-> B4
        B4 -.-> B5[Bottom]
    end

    subgraph AfterPop["After POP()"]
        direction TB
        C1[" "]
        C2[30]
        C3[20]
        C4[10]
        C1 -.-> C2
        C2 -.-> C3
        C3 -.-> C4
        C4 -.-> C5[Bottom]
    end

    Initial -->|"PUSH(40)"| AfterPush
    AfterPush -->|"POP() returns 40"| AfterPop

    style B1 fill:#90EE90
    style A1 fill:#f0f0f0
    style C1 fill:#f0f0f0
    
    style Initial fill:#e1f5ff
    style AfterPush fill:#fff4e1
    style AfterPop fill:#ffe1f5
```

## Concept and Walkthrough
```cpp
; MASM Program - Comprehensive Stack Operations Demo
; Demonstrates all types of data that can be pushed to the stack

.386
.model flat, stdcall
.stack 4096

.data
    myByte      BYTE 42h           ; Byte value
    myWord      WORD 1234h         ; Word value
    myDword     DWORD 12345678h    ; Double word value
    memValue    DWORD 0ABCDh       ; Memory variable
    
.code
main PROC
    ; 1. Push immediate values (constants)
    PUSH 10                        ; Push immediate decimal
    PUSH 0FFh                      ; Push immediate hex
    
    ; 2. Push 16-bit registers
    MOV AX, 5678h
    PUSH AX                        ; Push 16-bit register
    
    ; 3. Push 32-bit registers
    MOV EBX, 11223344h
    PUSH EBX                       ; Push 32-bit register
    
    MOV ECX, 99887766h
    PUSH ECX                       ; Push another 32-bit register
    
    ; 4. Push memory operands
    PUSH myDword                   ; Push DWORD from memory
    PUSH myWord                    ; Push WORD from memory
    
    ; 5. Push EFLAGS register
    PUSHFD                         ; Push 32-bit flags register
    
    ; 6. Push all general purpose registers
    PUSHAD                         ; Push EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI
    
    ; 7. Push segment registers (16-bit)
    PUSH DS                        ; Push data segment
    PUSH ES                        ; Push extra segment
    
    ; Now pop everything back in reverse order
    POP ES
    POP DS
    POPAD                          ; Pop all general purpose registers
    POPFD                          ; Pop flags
    POP myWord
    POP myDword
    POP ECX
    POP EBX
    POP AX
    ADD ESP, 8                     ; Clean up the two immediate values
    
    ; Exit program
    MOV EAX, 0
    RET
main ENDP

END main
```

### Summary
1. Immediate values (8, 16, 32-bit constants)
2. General purpose registers (AX, EAX, EBX, ECX, EDX, ESI, EDI, EBP)
3. Memory operands (BYTE, WORD, DWORD variables)
4. Flags register (PUSHF/PUSHFD for 16/32-bit)
5. All registers at once (PUSHA/PUSHAD for 16/32-bit)
6. Segment registers (CS, DS, ES, SS, FS, GS)

NOTES:
- PUSH always uses word or doubleword operands (2 or 4 bytes)
- Stack grows downward (toward lower memory addresses)
- ESP register automatically decrements with each PUSH
- PUSH of immediate byte values are sign-extended to word/dword

#### Diagram
```mermaid
graph LR
    subgraph S0["Initial State"]
        direction TB
        A0[Empty Stack]
        style A0 fill:#f0f0f0
    end

    subgraph S1["After PUSH 10<br/>PUSH 0FFh"]
        direction TB
        B1[0FFh]
        B2[10]
        B1 -.-> B2
        B2 -.-> B3[Bottom]
    end

    subgraph S2["After PUSH AX<br/>value: 5678h"]
        direction TB
        C1[5678h]
        C2[0FFh]
        C3[10]
        C1 -.-> C2
        C2 -.-> C3
        C3 -.-> C4[Bottom]
    end

    subgraph S3["After PUSH EBX, ECX<br/>EBX=11223344h<br/>ECX=99887766h"]
        direction TB
        D1[99887766h]
        D2[11223344h]
        D3[5678h]
        D4[0FFh]
        D5[10]
        D1 -.-> D2
        D2 -.-> D3
        D3 -.-> D4
        D4 -.-> D5
        D5 -.-> D6[Bottom]
    end

    subgraph S4["After Memory<br/>& Flags Push"]
        direction TB
        E1[EFLAGS]
        E2[myWord]
        E3[myDword]
        E4[99887766h]
        E5[11223344h]
        E6[5678h]
        E7[0FFh]
        E8[10]
        E1 -.-> E2
        E2 -.-> E3
        E3 -.-> E4
        E4 -.-> E5
        E5 -.-> E6
        E6 -.-> E7
        E7 -.-> E8
        E8 -.-> E9[Bottom]
    end

    subgraph S5["After PUSHAD<br/>8 registers"]
        direction TB
        F1[EDI]
        F2[ESI]
        F3[EBP]
        F4[ESP]
        F5[EBX]
        F6[EDX]
        F7[ECX]
        F8[EAX]
        F9[EFLAGS]
        F10[myWord]
        F11[...]
        F1 -.-> F2
        F2 -.-> F3
        F3 -.-> F4
        F4 -.-> F5
        F5 -.-> F6
        F6 -.-> F7
        F7 -.-> F8
        F8 -.-> F9
        F9 -.-> F10
        F10 -.-> F11
    end

    subgraph S6["After Segment<br/>Registers"]
        direction TB
        G1[ES]
        G2[DS]
        G3[EDI]
        G4[ESI]
        G5[EBP]
        G6[ESP]
        G7[EBX]
        G8[EDX]
        G9[ECX]
        G10[EAX]
        G11[...]
        G1 -.-> G2
        G2 -.-> G3
        G3 -.-> G4
        G4 -.-> G5
        G5 -.-> G6
        G6 -.-> G7
        G7 -.-> G8
        G8 -.-> G9
        G9 -.-> G10
        G10 -.-> G11
    end

    S0 -->|"Immediates"| S1
    S1 -->|"16-bit Reg"| S2
    S2 -->|"32-bit Regs"| S3
    S3 -->|"Memory+Flags"| S4
    S4 -->|"PUSHAD"| S5
    S5 -->|"PUSH DS/ES"| S6

    style G1 fill:#90EE90
    style G2 fill:#90EE90
    style F1 fill:#FFD700
    style E1 fill:#87CEEB
```

### POP Walkthrough
```mermaid
graph LR
    subgraph S6["Full Stack"]
        direction TB
        G1[ES]
        G2[DS]
        G3[EDI]
        G4[ESI]
        G5[EBP]
        G6[ESP]
        G7[EBX]
        G8[EDX]
        G9[ECX]
        G10[EAX]
        G11[EFLAGS]
        G12[myWord]
        G13[myDword]
        G14[99887766h]
        G15[11223344h]
        G16[5678h]
        G17[0FFh]
        G18[10]
        G1 -.-> G2
        G2 -.-> G3
        G3 -.-> G4
        G4 -.-> G5
        G5 -.-> G6
        G6 -.-> G7
        G7 -.-> G8
        G8 -.-> G9
        G9 -.-> G10
        G10 -.-> G11
        G11 -.-> G12
        G12 -.-> G13
        G13 -.-> G14
        G14 -.-> G15
        G15 -.-> G16
        G16 -.-> G17
        G17 -.-> G18
        G18 -.-> G19[Bottom]
    end

    subgraph S5["After POP ES<br/>POP DS"]
        direction TB
        F3[EDI]
        F4[ESI]
        F5[EBP]
        F6[ESP]
        F7[EBX]
        F8[EDX]
        F9[ECX]
        F10[EAX]
        F11[EFLAGS]
        F12[myWord]
        F13[myDword]
        F14[99887766h]
        F15[11223344h]
        F16[5678h]
        F17[0FFh]
        F18[10]
        F3 -.-> F4
        F4 -.-> F5
        F5 -.-> F6
        F6 -.-> F7
        F7 -.-> F8
        F8 -.-> F9
        F9 -.-> F10
        F10 -.-> F11
        F11 -.-> F12
        F12 -.-> F13
        F13 -.-> F14
        F14 -.-> F15
        F15 -.-> F16
        F16 -.-> F17
        F17 -.-> F18
        F18 -.-> F19[Bottom]
    end

    subgraph S4["After POPAD<br/>8 registers popped"]
        direction TB
        E1[EFLAGS]
        E2[myWord]
        E3[myDword]
        E4[99887766h]
        E5[11223344h]
        E6[5678h]
        E7[0FFh]
        E8[10]
        E1 -.-> E2
        E2 -.-> E3
        E3 -.-> E4
        E4 -.-> E5
        E5 -.-> E6
        E6 -.-> E7
        E7 -.-> E8
        E8 -.-> E9[Bottom]
    end

    subgraph S3["After POPFD<br/>POP myWord<br/>POP myDword"]
        direction TB
        D1[99887766h]
        D2[11223344h]
        D3[5678h]
        D4[0FFh]
        D5[10]
        D1 -.-> D2
        D2 -.-> D3
        D3 -.-> D4
        D4 -.-> D5
        D5 -.-> D6[Bottom]
    end

    subgraph S2["After POP ECX<br/>POP EBX<br/>POP AX"]
        direction TB
        C1[0FFh]
        C2[10]
        C1 -.-> C2
        C2 -.-> C3[Bottom]
    end

    subgraph S1["After ADD ESP, 8<br/>Clean immediates"]
        direction TB
        A0[Empty Stack]
        style A0 fill:#90EE90
    end

    S6 -->|"POP ES, DS"| S5
    S5 -->|"POPAD"| S4
    S4 -->|"POPFD, POPs"| S3
    S3 -->|"POP Regs"| S2
    S2 -->|"Cleanup"| S1

    style G1 fill:#FFB6C1
    style G2 fill:#FFB6C1
    style F3 fill:#FFD700
    style E1 fill:#87CEEB
    style A0 fill:#90EE90
```

### Push in procedure calling
```cpp
; MASM Program - Function Argument Order Demo
; Function: Subtract(minuend, subtrahend) = minuend - subtrahend
; This demonstrates why argument order matters!

.386
.model flat, stdcall
.stack 4096

.data
    result1 DWORD ?
    result2 DWORD ?
    
.code

; Function: Subtract two numbers
; Parameters: minuend (first), subtrahend (second)
; Returns: minuend - subtrahend in EAX
; Formula: Subtract(10, 3) = 10 - 3 = 7
Subtract PROC
    PUSH EBP                    ; Save base pointer
    MOV EBP, ESP                ; Set up stack frame
    
    ; Stack layout at this point:
    ; [EBP+12] = first parameter (minuend)
    ; [EBP+8]  = second parameter (subtrahend)
    ; [EBP+4]  = return address
    ; [EBP]    = saved EBP
    
    MOV EAX, [EBP+12]          ; Get first parameter (minuend)
    SUB EAX, [EBP+8]           ; Subtract second parameter (subtrahend)
    
    POP EBP                     ; Restore base pointer
    RET 8                       ; Return and clean 8 bytes (2 parameters)
Subtract ENDP

main PROC
    ; ==========================================
    ; CORRECT ORDER: Subtract(10, 3) = 10 - 3 = 7
    ; ==========================================
    PUSH 3                      ; Push subtrahend (second parameter)
    PUSH 10                     ; Push minuend (first parameter)
    CALL Subtract               ; Result in EAX = 7
    MOV result1, EAX            ; Store result (should be 7)
    
    ; ==========================================
    ; WRONG ORDER: Arguments swapped!
    ; We want Subtract(10, 3) but push in wrong order
    ; This gives us Subtract(3, 10) = 3 - 10 = -7
    ; ==========================================
    PUSH 10                     ; Push minuend (WRONG - should be second!)
    PUSH 3                      ; Push subtrahend (WRONG - should be first!)
    CALL Subtract               ; Result in EAX = -7 (WRONG!)
    MOV result2, EAX            ; Store result (will be -7, not 7!)
    
    ; Exit program
    MOV EAX, 0
    RET
main ENDP

END main
```

EXPLANATION:
result1 = 7  (CORRECT: 10 - 3)
result2 = -7 (WRONG: 3 - 10)

The function expects:
- [EBP+12] = minuend (number to subtract FROM)
- [EBP+8]  = subtrahend (number to subtract)

Parameters are pushed RIGHT-TO-LEFT (stdcall convention)
So for Subtract(10, 3):
1. PUSH 3  (second parameter - subtrahend)
2. PUSH 10 (first parameter - minuend)
3. CALL Subtract

The last pushed value (10) is accessed first as [EBP+12]
The first pushed value (3) is accessed second as [EBP+8]

```mermaid
graph LR
    subgraph Correct["CORRECT ORDER<br/>Subtract(10, 3)"]
        direction LR
        
        subgraph C1["1. PUSH 3<br/>(subtrahend)"]
            direction TB
            A1[3]
            A1 -.-> A2[Bottom]
        end
        
        subgraph C2["2. PUSH 10<br/>(minuend)"]
            direction TB
            B1[10]
            B2[3]
            B1 -.-> B2
            B2 -.-> B3[Bottom]
        end
        
        subgraph C3["3. CALL Subtract<br/>(pushes return addr)"]
            direction TB
            C1A[Return Addr]
            C2A[10]
            C3A[3]
            C1A -.-> C2A
            C2A -.-> C3A
            C3A -.-> C4A[Bottom]
        end
        
        subgraph C4["4. PUSH EBP<br/>(save base ptr)"]
            direction TB
            D1[Saved EBP]
            D2[Return Addr]
            D3["10 ‚Üê EBP+12"]
            D4["3 ‚Üê EBP+8"]
            D1 -.-> D2
            D2 -.-> D3
            D3 -.-> D4
            D4 -.-> D5[Bottom]
        end
        
        subgraph C5["5. Execute<br/>EAX = 10 - 3"]
            direction TB
            E1["Result: EAX = 7 ‚úì"]
            style E1 fill:#90EE90
        end
        
        C1 --> C2
        C2 --> C3
        C3 --> C4
        C4 --> C5
    end
    
    subgraph Wrong["WRONG ORDER<br/>Arguments Swapped!"]
        direction LR
        
        subgraph W1["1. PUSH 10<br/>(WRONG!)"]
            direction TB
            F1[10]
            F1 -.-> F2[Bottom]
        end
        
        subgraph W2["2. PUSH 3<br/>(WRONG!)"]
            direction TB
            G1[3]
            G2[10]
            G1 -.-> G2
            G2 -.-> G3[Bottom]
        end
        
        subgraph W3["3. CALL Subtract<br/>(pushes return addr)"]
            direction TB
            H1[Return Addr]
            H2[3]
            H3[10]
            H1 -.-> H2
            H2 -.-> H3
            H3 -.-> H4[Bottom]
        end
        
        subgraph W4["4. PUSH EBP<br/>(save base ptr)"]
            direction TB
            I1[Saved EBP]
            I2[Return Addr]
            I3["3 ‚Üê EBP+12 üíÄ"]
            I4["10 ‚Üê EBP+8 üíÄ"]
            I1 -.-> I2
            I2 -.-> I3
            I3 -.-> I4
            I4 -.-> I5[Bottom]
        end
        
        subgraph W5["5. Execute<br/>EAX = 3 - 10"]
            direction TB
            J1["Result: EAX = -7 ‚úó"]
            style J1 fill:#FFB6C1
        end
        
        W1 --> W2
        W2 --> W3
        W3 --> W4
        W4 --> W5
    end
    
    style D3 fill:#87CEEB
    style D4 fill:#FFD700
    style I3 fill:#FF6B6B
    style I4 fill:#FF6B6B
```


# The Mechanics of `CALL` and `RET`

**‚ö†Ô∏è CRITICAL:** This is the number one area where students lose marks. You must understand how the Instruction Pointer (EIP) interacts with the stack.

---

## How `CALL` Actually Works

When you write `CALL MyProc`:

1. The CPU calculates the address of the instruction immediately following the CALL (the **Return Address**)
2. It **PUSHES** that Return Address onto the stack
3. It copies the address of `MyProc` into `EIP` (Instruction Pointer)
4. The CPU executes instructions at `EIP`

---

## How `RET` Actually Works

When the CPU hits `RET`:

1. It **POPS** the value from the top of the stack
2. It copies that value into `EIP`
3. Execution resumes at that address

### üß† Mind-Bending Implication

If you `PUSH` a random value onto the stack and then execute `RET`, the CPU will try to "return" to that random address, causing a crash (**Segmentation Fault**).

---

## The `USES` Operator

Instead of manually typing `push ebx` / `pop ebx`, MASM provides the `USES` operator to automate this in the procedure definition.

### Syntax

```asm
MyProcedure PROC USES eax ebx ecx
    mov eax, 10
    mov ebx, 20
    mov ecx, 30
    ret
MyProcedure ENDP
```

### What MASM Generates Behind the Scenes

```asm
push eax
push ebx
push ecx
; ... your code ...
pop ecx
pop ebx
pop eax
ret
```

**‚ö†Ô∏è Note:** The reverse order of popping!

---

## Mind-Bending Scenarios (Edge Cases)

### Scenario A: The Stack Corruption (The "Mismatched Push")

```asm
MyProc PROC
    push eax        ; Save EAX
    mov eax, 10
    ; Forgot to pop EAX!
    ret             ; RET pops the top of stack... which is EAX!
MyProc ENDP
```

**Result:** üî¥ **CRITICAL FAILURE**

The `RET` instruction blindly pops the top value. It thinks the old EAX value is the Return Address. It jumps to `EAX` (value 10 or whatever was in it). The program crashes because it's executing garbage memory.

---

### Scenario B: Manual Jumps Using RET

**Concept:** You can use `RET` to jump to a specific label without using `JMP`.

```asm
    push OFFSET TargetLabel  ; Push address of label
    ret                      ; "Returns" to TargetLabel
TargetLabel:
    ; Code continues here
```

**Why use this?** Obfuscation or writing exploit shellcode.

---

### Scenario C: Nested Calls and Stack Growth

If Proc A calls Proc B, and Proc B calls Proc C:

- Stack contains: `[Ret Addr for A]` ‚Üí `[Ret Addr for B]` ‚Üí `[Ret Addr for C]`
- As functions return, the stack "unwinds"

---

### Scenario D: Stack Overflow (Infinite Recursion)

```asm
RecursiveProc PROC
    call RecursiveProc   ; Calls itself forever
    ret
RecursiveProc ENDP
```

**Result:**

1. Pushes Return Address
2. Decrements ESP
3. Repeats until ESP hits the bottom of the reserved stack memory
4. **Stack Overflow Exception**

---

## MCQ Trap Zone

Concepts likely to trick you in multiple-choice questions.

### Question 1: Does `PUSH` increase or decrease memory addresses?

**Answer:** **Decrease**. The stack grows downward (from high memory to low memory). Pushing subtracts 4 from ESP.

---

### Question 2: If `ESP = 00001000h` and you execute `PUSH EAX`, what is `ESP`?

**Answer:** `00000FFCh` (1000h - 4 = FFCh)

---

### Question 3: What happens if you define a procedure without `RET`?

**Answer:** The CPU performs **"fall-through."** It continues executing whatever bytes are in memory after the procedure, likely causing a crash or executing the next procedure immediately.

---

### Question 4: Can you pass parameters using the stack?

**Answer:** **Yes!** You `PUSH` arguments before the `CALL`. (This is standard in C/C++, though Chapter 5 mostly focuses on register parameters)

---

### Question 5: What is the difference between `RET` and `RET n` (e.g., `RET 8`)?

**Answer:**

- `RET` just pops EIP
- `RET n` pops EIP **AND** adds `n` to ESP

This is used to "clean up" arguments pushed onto the stack (**StdCall convention**).

---

## Quick Reference: Stack Behavior

|Instruction|Effect on ESP|Effect on Stack|
|---|---|---|
|`PUSH EAX`|ESP = ESP - 4|Stores EAX at [ESP]|
|`POP EAX`|ESP = ESP + 4|Loads EAX from [ESP]|
|`CALL MyProc`|ESP = ESP - 4|Pushes Return Address|
|`RET`|ESP = ESP + 4|Pops into EIP|
|`RET 8`|ESP = ESP + 12|Pops EIP, then ESP += 8|

---

## Key Takeaways

‚úÖ **Always match PUSH/POP pairs** - Unbalanced stack = crash  
‚úÖ **CALL = PUSH return address + JMP**  
‚úÖ **RET = POP into EIP**  
‚úÖ **Stack grows downward** (high ‚Üí low memory)  
‚úÖ **USES operator auto-generates PUSH/POP** (in reverse order)  
‚úÖ **No RET = fall-through execution** (dangerous!)

---

_Study this guide thoroughly - stack mechanics are fundamental to understanding assembly procedures and are a common source of exam questions._