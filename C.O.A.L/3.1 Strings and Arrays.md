# Advanced Strings and Arrays (The Missing Manual)

## 1. The "Hidden" Hardware Logic

In high-level languages, a string is an object. In x86 assembly, a "string" is simply a continuous block of bytes, words, or doublewords in memory. What makes Chapter 9 special is that the CPU has dedicated hardware circuitry specifically optimized to process these blocks faster than standard loops.

To use these instructions, you must understand the three "Hardwired" registers. These are not choices; the CPU _expects_ data to be here:

- **ESI (Source Index):** Always points to the memory address you are reading _from_.
    
- **EDI (Destination Index):** Always points to the memory address you are writing _to_.
    
- **ECX (Counter):** Used by the `REP` prefix to count iterations.
    

### The Direction Flag (DF): The Traffic Cop

The most critical concept in string processing is the Direction Flag. It dictates whether the CPU processes memory "forward" (low address to high address) or "backward" (high address to low address).

When an instruction like `MOVSB` executes, it copies data _and_ updates ESI and EDI automatically. The update direction depends entirely on DF:

- **CLD (Clear Direction Flag):** Sets DF = 0. ESI and EDI are **incremented**. Use this for standard array processing (Index 0 -> Index N).
    
- **STD (Set Direction Flag):** Sets DF = 1. ESI and EDI are **decremented**. Use this for processing arrays in reverse (Index N -> Index 0).
    

**Mind-Bending Scenario:** If you forget to clear the direction flag (`CLD`) at the start of your procedure, and a previous function set it to `STD`, your loop will walk backwards through memory, reading garbage data before your array starts and overwriting memory before your destination buffer. This causes the infamous "Buffer Underrun" crash.

## 2. The Five Primitives (Deep Dive)

These instructions perform an operation and then _simultaneously_ update the index registers.

### A. MOVSB, MOVSW, MOVSD (Move String Data)

These instructions copy data from `[ESI]` to `[EDI]`.

- **MOVSB:** Copies 1 byte. ESI/EDI change by +/- 1.
    
- **MOVSW:** Copies 2 bytes. ESI/EDI change by +/- 2.
    
- **MOVSD:** Copies 4 bytes. ESI/EDI change by +/- 4.
    

**Detailed Execution Flow:**

1. Read value at memory address `ESI`.
    
2. Write value to memory address `EDI`.
    
3. Check DF. If 0, add size (1/2/4) to ESI and EDI. If 1, subtract size.
    

### B. CMPSB, CMPSW, CMPSD (Compare String Data)

This performs a comparison `[ESI] - [EDI]` but **discards the result**, updating only the flags.

- **Use Case:** Comparing two strings for equality.
    
- **Critical Detail:** It compares Source to Destination. If `[ESI] > [EDI]`, the result is positive, so flags are set accordingly.
    

### C. SCASB, SCASW, SCASD (Scan String Data)

This compares the Accumulator (AL/AX/EAX) to the memory at `[EDI]`.

- **Note:** It uses **EDI**, not ESI. This is unique! It assumes you are scanning a destination buffer looking for a specific value (like looking for a null terminator in a string).
    
- **Logic:** `AL - [EDI]`.
    

### D. STOSB, STOSW, STOSD (Store String Data)

This copies the value in the Accumulator (AL/AX/EAX) to memory at `[EDI]`.

- **Use Case:** Initializing an array to zero or filling a buffer with a specific character.
    
- **Efficiency:** It is significantly faster than a loop with `MOV [EDI], AL` because the incrementing logic is hardware-accelerated.
    

### E. LODSB, LODSW, LODSD (Load String Data)

This copies the value at memory `[ESI]` into the Accumulator (AL/AX/EAX).

- **Why use it?** It is rarely used with `REP` because loading a value 100 times overwrites the register 99 times. It is mostly used inside a custom loop where you need to load a byte, process it, and then check a complex condition.
    

## 3. The REP Prefixes (The Engine)

The primitives above process only _one_ element. To process an entire array, we prefix the instruction with `REP`.

### The Logic of `REP`

The `REP` prefix tells the CPU: "Repeat the following instruction, decrementing ECX each time, until ECX is zero."

**Cycle Logic:**

1. Check if `ECX == 0`. If yes, exit immediately (do nothing).
    
2. Execute the string instruction (e.g., `MOVSB`).
    
3. Decrement `ECX` by 1.
    
4. Jump back to Step 1.
    

**Edge Case: ECX = 0** If ECX is 0 before the line runs, the instruction executes **zero times**. This is a safety feature, preventing "infinite" loops (unlike a `do-while` loop which typically runs at least once).

### Conditional Repeats (`REPE` / `REPNE`)

For Comparison (CMPS) and Scanning (SCAS), we usually want to stop _early_ if we find a match or a mismatch.

- **REPE (Repeat while Equal):** Repeats while `ECX > 0` AND `ZF = 1`.
    
    - Used to find the _first difference_ between two strings.
        
- **REPNE (Repeat while Not Equal):** Repeats while `ECX > 0` AND `ZF = 0`.
    
    - Used to find a specific value (like a null terminator) in a string.
        

**Example: Calculating String Length (strlen)** We want to scan for the null terminator (0). We use `SCASB` with `REPNE`.

```
.data
myStr BYTE "Hello World", 0

.code
    cld             ; Always clear direction flag first!
    mov edi, OFFSET myStr
    mov al, 0       ; Value to look for (null terminator)
    mov ecx, -1     ; Set counter to Max Integer (FFFFFFFFh)
    
    repne scasb     ; Repeat while Not Equal to 0.
                    ; Decrements ECX for every char checked.

    ; Math magic to find length:
    ; Length = (Start Counter) - (End Counter) - 1
    not ecx         ; Inverts bits (effectively Max - Current)
    dec ecx         ; Adjust for the null terminator itself
```

## 4. Two-Dimensional Arrays (Row-Major Order)

Memory is 1-dimensional (a single line of bytes). A 2D array is an abstraction where we place rows one after another.

**The Formula:** To access `Array[row][col]`:

```
Effective Address = BaseOffset + (RowIndex * RowSize) + (ColIndex * ElementSize)
```

**Step-by-Step Implementation:** Imagine a 5x5 array of Bytes. `RowSize` = 5 bytes (5 columns * 1 byte per element).

To access `Array[2][3]` (Row 2, Column 3):

1. **Skip previous rows:** We must skip Row 0 and Row 1.
    
    - `2 * 5 = 10` bytes.
        
2. **Skip previous columns:** We must skip Col 0, Col 1, Col 2.
    
    - `3 * 1 = 3` bytes.
        
3. **Total Offset:** `10 + 3 = 13` bytes from the start.
    

**Assembly Code Example:**

```
.data
TableB  BYTE  10h, 20h, 30h, 40h, 50h
        RowSize = ($ - TableB)      ; RowSize = 5
        BYTE  60h, 70h, 80h, 90h, 0A0h
        BYTE  0B0h, 0C0h, 0D0h, 0E0h, 0F0h

.code
    mov ebx, OFFSET TableB   ; Base Address
    mov eax, 1               ; Desired Row Index
    mov esi, 2               ; Desired Column Index

    ; Calculate Row Offset
    mov edx, RowSize         ; Load 5
    mul edx                  ; EAX = 1 * 5 = 5
    
    ; Add Column Offset
    add eax, esi             ; EAX = 5 + 2 = 7
    
    ; Access Element
    mov al, [ebx + eax]      ; Load byte at TableB[7] (which is 80h)
```

## 5. MCQs (The Trap Zone)

**1. What happens if you execute `REP MOVSB` without initializing `ECX`?**

- **Answer:** The CPU will repeat the move operation a random number of times (whatever value happened to be in ECX). If ECX was huge, you will overwrite massive amounts of memory, likely crashing the OS or corrupting other programs. This is a classic "Heisenbug."
    

**2. Why do we usually set `ECX = -1` (FFFFFFFFh) when using `REPNE SCASB` for string length?**

- **Answer:** We don't know the string length yet, so we give it the maximum possible counter value to ensure it doesn't stop prematurely. `FFFFFFFFh` acts as "infinity" in this context.
    

**3. In `REPNE SCASB`, if the value is NOT found, what is the state of the Zero Flag (ZF)?**

- **Answer:** `ZF = 0`. The loop stopped because `ECX` hit 0, not because it found a match. If it _had_ found a match, `ZF` would be 1.
    

**4. Does `STD` affect the `CMP` instruction?**

- **Answer:** **No.** `CMP` is a standard arithmetic instruction. `STD` only affects string primitives (MOVS, CMPS, SCAS, STOS, LODS).
    

**5. If `ESI = 1000` and `DF = 1`, what is `ESI` after `MOVSW` executes once?**

- **Answer:** **998.** Since DF=1 (Reverse), it decrements. Since it is `MOVSW` (Word), it decrements by 2 bytes.