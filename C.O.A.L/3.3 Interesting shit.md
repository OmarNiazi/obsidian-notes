```cpp
.386
.model flat, stdcall
.stack 4096

ExitProcess PROTO, dwExitCode:DWORD

.data
	arr db 1, 2, 3, 4, 5
	ptr1 dd arr
	ptr2 dd ptr1
	ptr3 dd ptr2

	optr dd offset arr

.code
main PROC 
	
	mov al, arr
	mov eax, [ptr1]
	mov eax, [eax]
	mov ebx, [ptr2]
	mov ebx, [ebx]
	mov ebx, [ebx]
	mov ecx, [ptr3]
	mov ecx, [ecx]
	mov ecx, [ecx]
	mov ecx, [ecx]

	mov edx, [optr]
	mov edx, [edx]

	invoke ExitProcess, 0

main endp
END main
```

```cpp
INCLUDE Irvine32.inc

.data
    ; --- UI Strings ---
    sep         BYTE "-----------------------------------------------------",0
    header      BYTE "INSTR    OPERANDS       BINARY RESULT           FLAGS",0
    fmtString   BYTE "  ->     ",0
    cfLabel     BYTE " CF=",0
    ofLabel     BYTE " OF=",0
    sfLabel     BYTE " SF=",0
    zfLabel     BYTE " ZF=",0
    
    ; --- Explanations ---
    msgBasic    BYTE "1. LOGICAL SHIFTS (Unsigned Math)",0
    msgArith    BYTE "2. ARITHMETIC SHIFTS (Signed Math - Watch the Sign Bit!)",0
    msgRot      BYTE "3. ROTATIONS (Preserving Bits)",0
    msgCarry    BYTE "4. CARRY ROTATIONS (Using CF as a 9th bit)",0
    msgDouble   BYTE "5. DOUBLE PRECISION (SHLD/SHRD - The 'Bucket Brigade')",0
    msgEdge     BYTE "6. EDGE CASES (The 'Gotchas' of x86)",0
    
    ; --- Dynamic Labels for our Analyzer ---
    lbl_shl     BYTE "SHL      EAX, 1       ",0
    lbl_shl4    BYTE "SHL      EAX, 4       ",0
    lbl_shr     BYTE "SHR      EAX, 1       ",0
    lbl_sar     BYTE "SAR      AL,  1       ",0
    lbl_sal     BYTE "SAL      AL,  1       ",0
    lbl_rol     BYTE "ROL      AL,  1       ",0
    lbl_rcl     BYTE "RCL      AL,  1       ",0
    lbl_cl      BYTE "SHL      EAX, CL      ",0
    lbl_shld    BYTE "SHLD     AX, BX, 4    ",0
    lbl_zero    BYTE "SHL      EAX, 0       ",0
    lbl_32      BYTE "SHL      EAX, 32      ",0
    lbl_33      BYTE "SHL      EAX, 33      ",0

.code
main PROC
    ; ===============================================================
    ; SECTION 1: LOGICAL SHIFTS & OPERAND CONFIGS
    ; Config A: Immediate (Hardcoded number)
    ; Config B: CL Register (Variable shift count)
    ; ===============================================================
    mov edx, OFFSET msgBasic
    call PrintHeader

    ; Case 1: Standard SHL by 1 (Immediate)
    ; Value: 0000 0001 (1) -> 0000 0010 (2)
    mov eax, 1
    mov edx, OFFSET lbl_shl
    shl eax, 1         ; <--- IMMEDIATE OPERAND
    call ShowState

    ; Case 2: SHL by Variable (Must use CL register)
    ; Value: 0000 0010 (2) -> Shift by 4 -> 0010 0000 (32)
    mov cl, 4          ; Load shift count into CL
    mov edx, OFFSET lbl_cl
    shl eax, cl        ; <--- CL OPERAND (The only register allowed for count!)
    call ShowState

    ; Case 3: Overflow Detection (Only valid for 1-bit shifts)
    ; If the Sign Bit changes during a 1-bit shift, OF is set.
    mov eax, 01000000h ; Top bit is 0, next is 1
    mov edx, OFFSET lbl_shl
    shl eax, 1         ; Top bit becomes 1 (Sign change!)
    call ShowState     ; Watch OF become 1

    ; ===============================================================
    ; SECTION 2: ARITHMETIC SHIFTS (THE TRAP)
    ; Difference: SAR duplicates the Sign Bit to preserve negativity.
    ; ===============================================================
    mov edx, OFFSET msgArith
    call PrintHeader

    ; Case 1: Negative Number (-8 in 8-bit is F8 or 11111000)
    mov al, 0F8h       
    mov edx, OFFSET lbl_sar
    sar al, 1          ; Arithmetic Shift Right
    call ShowState8    ; Result: 11111100 (-4). Sign bit '1' was copied in.

    ; Case 2: Logical Shift on same number (Destroys the sign)
    mov al, 0F8h       ; -8
    mov edx, OFFSET lbl_shr
    shr al, 1          ; Logical Shift Right
    call ShowState8    ; Result: 01111100 (+124). Sign bit became '0'.

    ; ===============================================================
    ; SECTION 3: ROTATIONS (No bits lost)
    ; ===============================================================
    mov edx, OFFSET msgRot
    call PrintHeader

    mov al, 10000001b  ; Bounds
    mov edx, OFFSET lbl_rol
    rol al, 1          ; The '1' on left wraps to the right
    call ShowState8    ; Result: 00000011

    ; ===============================================================
    ; SECTION 4: CARRY ROTATIONS (RCL / RCR)
    ; The 9-bit Circle: [CF] - [Reg]
    ; ===============================================================
    mov edx, OFFSET msgCarry
    call PrintHeader

    ; Setup: Carry=1, AL=0
    stc                ; Set Carry Flag Manually
    mov al, 0
    mov edx, OFFSET lbl_rcl
    
    ; Action: Rotate Left through Carry
    ; The 1 from CF goes into AL. The 0 from top of AL goes into CF.
    rcl al, 1          
    call ShowState8    ; Result: 00000001, CF=0

    ; ===============================================================
    ; SECTION 5: DOUBLE PRECISION (SHLD / SHRD)
    ; Syntax: SHLD Dest, Source, Count
    ; Action: Shifts Dest left. Fills empty bits with high bits of Source.
    ;         Source is NOT modified.
    ; ===============================================================
    mov edx, OFFSET msgDouble
    call PrintHeader

    mov ax, 0F000h     ; Dest:   1111 0000 0000 0000
    mov bx, 0AAAAh     ; Source: 1010 1010 1010 1010
    mov edx, OFFSET lbl_shld
    
    ; Shift AX left by 4. Fill the hole with top 4 bits of BX (1010).
    shld ax, bx, 4     
    
    ; AX Expected: 0000 0000 0000 1010 (F000 shifted left 4 clears it, A comes in)
    call ShowState16   ; NOTE: Using 16-bit visualizer

    ; ===============================================================
    ; SECTION 6: EDGE CASES (THE GOTCHAS)
    ; ===============================================================
    mov edx, OFFSET msgEdge
    call PrintHeader

    ; Case 1: Shifting by 0
    ; CPU Behavior: NOP. Flags are NOT affected.
    mov eax, 0FFFFFFFFh
    mov edx, OFFSET lbl_zero
    shl eax, 0
    call ShowState     ; Flags remain exactly as they were before.

    ; Case 2: The Modulo 32 Rule
    ; On x86 32-bit, the shift count is masked by 31 (0x1F).
    ; Count = 32 becomes 0.
    ; Count = 33 becomes 1.
    
    mov eax, 1         ; Start with 1
    mov edx, OFFSET lbl_32
    shl eax, 32        ; Effectively shl eax, 0
    call ShowState     ; Result: 1 (Unchanged!)

    mov eax, 1         ; Start with 1
    mov edx, OFFSET lbl_33
    shl eax, 33        ; Effectively shl eax, 1
    call ShowState     ; Result: 2

    invoke ExitProcess, 0
main ENDP

; ------------------------------------------------------------------
; ShowState (32-bit version)
; Input: EAX = Result, EDX = Pointer to Label String
; ------------------------------------------------------------------
ShowState PROC
    pushad              ; Save all registers
    pushfd              ; Save Flags immediately (so logic doesn't mess them up)

    ; 1. Print Instruction Label
    call WriteString
    mov  edx, OFFSET fmtString
    call WriteString

    ; 2. Print Binary
    mov  ebx, 4         ; 4 bytes = 32 bits
    call WriteBinB      ; Irvine32 binary print
    
    ; 3. Analyze Flags
    popfd               ; Restore flags to check them
    pushfd              ; Save them again for later

    ; Check Carry Flag (CF)
    mov  edx, OFFSET cfLabel
    call WriteString
    jc   IsCarry
    mov  al, '0'
    jmp  PrtCarry
IsCarry:
    mov  al, '1'
PrtCarry:
    call WriteChar

    ; Check Overflow Flag (OF)
    mov  edx, OFFSET ofLabel
    call WriteString
    jo   IsOver
    mov  al, '0'
    jmp  PrtOver
IsOver:
    mov  al, '1'
PrtOver:
    call WriteChar

    ; Check Sign Flag (SF)
    mov  edx, OFFSET sfLabel
    call WriteString
    js   IsSign
    mov  al, '0'
    jmp  PrtSign
IsSign:
    mov  al, '1'
PrtSign:
    call WriteChar
    
    call Crlf
    popfd               ; Final restore
    popad
    ret
ShowState ENDP

; ------------------------------------------------------------------
; ShowState8 (8-bit version for AL)
; ------------------------------------------------------------------
ShowState8 PROC
    pushad
    pushfd
    
    call WriteString    ; Print Label
    mov  edx, OFFSET fmtString
    call WriteString

    movzx eax, al       ; Zero extend AL to EAX for cleaner print
    mov  ebx, 1         ; 1 byte
    call WriteBinB
    
    ; (Flag logic is identical, reusing same strategy...)
    popfd
    pushfd
    
    mov  edx, OFFSET cfLabel
    call WriteString
    jc   C1
    mov  al, '0'
    jmp  C2
C1: mov  al, '1'
C2: call WriteChar
    
    mov  edx, OFFSET sfLabel
    call WriteString
    js   S1
    mov  al, '0'
    jmp  S2
S1: mov  al, '1'
S2: call WriteChar

    call Crlf
    popfd
    popad
    ret
ShowState8 ENDP

; ------------------------------------------------------------------
; ShowState16 (16-bit version for AX)
; ------------------------------------------------------------------
ShowState16 PROC
    pushad
    pushfd
    call WriteString
    mov  edx, OFFSET fmtString
    call WriteString
    mov  ebx, 2         ; 2 bytes
    call WriteBinB
    call Crlf
    popfd
    popad
    ret
ShowState16 ENDP

; ------------------------------------------------------------------
; Helper for headers
; ------------------------------------------------------------------
PrintHeader PROC
    call Crlf
    call WriteString    ; Print Section Title
    call Crlf
    mov  edx, OFFSET sep
    call WriteString
    call Crlf
    mov  edx, OFFSET header
    call WriteString
    call Crlf
    mov  edx, OFFSET sep
    call WriteString
    call Crlf
    ret
PrintHeader ENDP

END main
```

```cpp
INCLUDE Irvine32.inc

.data
    msgInput1   BYTE "Enter Multiplicand (EAX): ",0
    msgInput2   BYTE "Enter Multiplier   (EBX): ",0
    msgResult   BYTE "Result (Calculated by Shifts): ",0
    msgCheck    BYTE "Check  (Calculated by MUL):    ",0

.code
main PROC
    ; 1. Get Inputs
    mov edx, OFFSET msgInput1
    call WriteString
    call ReadDec
    mov ebx, eax        ; Move first input to EBX temporarily

    mov edx, OFFSET msgInput2
    call WriteString
    call ReadDec
    
    ; Setup: EAX = Multiplicand, EBX = Multiplier
    xchg eax, ebx       ; Swap so EAX is Multiplicand, EBX is Multiplier

    ; --- SAVE DATA ---
    push eax            ; Save original Multiplicand
    push ebx            ; Save original Multiplier

    ; 2. Call our custom Shift-Multiplier
    call BitwiseMultiply
    
    ; 3. Print Result
    mov edx, OFFSET msgResult
    call WriteString
    call WriteDec
    call Crlf

    ; --- RESTORE DATA ---
    mov edx, OFFSET msgCheck
    call WriteString
    
    pop ebx             ; Restore Multiplier
    pop eax             ; Restore Multiplicand
    
    ; 4. Verify with actual CPU MUL instruction
    mul ebx             ; Standard hardware multiply (EAX = EAX * EBX)
    call WriteDec       ; Print the hardware result
    call Crlf
    
    invoke ExitProcess, 0
main ENDP

;---------------------------------------------------------
; BitwiseMultiply
; Multiplies EAX by EBX using ONLY Shifts and Adds.
; Input:  EAX = Multiplicand (Value to be scaled)
;         EBX = Multiplier   (Pattern of bits)
; Output: EAX = Result
;---------------------------------------------------------
BitwiseMultiply PROC
    push edx            ; Save registers we will use
    push ecx
    push esi

    mov esi, 0          ; ESI will be our "Accumulator" (Result)
    
    ; We loop 32 times (max bits in a register), 
    ; or quit early if EBX becomes 0.
MultiplyLoop:
    cmp ebx, 0          ; Is Multiplier 0?
    je  Done            ; If yes, we are finished.

    ; CHECK: Is the bottom bit of EBX a 1?
    test ebx, 1         ; AND operation (doesn't change EBX, just flags)
    jz   SkipAdd        ; If ZeroFlag=1, bit was 0. Skip addition.

    ; ACTION: Add current EAX to Result
    add  esi, eax

SkipAdd:
    ; PREPARE FOR NEXT BIT
    shl  eax, 1         ; Double EAX (x1, x2, x4, x8...)
    shr  ebx, 1         ; Shift Multiplier Right to process next bit
    
    jmp  MultiplyLoop

Done:
    mov eax, esi        ; Move final result into EAX
    
    pop esi             ; Restore registers
    pop ecx
    pop edx
    ret
BitwiseMultiply ENDP

END main
```

```cpp
#include <iostream>
#include <cfenv> // Required for enabling exceptions (if supported)

using namespace std;

int main() {
    cout << "--- ZEROS ---" << endl;
    
    // 1. Positive Zero (+0.0)
    // Sign: 0, Exp: 0, Frac: 0
    int posZero = 0b00000000000000000000000000000000;
    float* fPosZero = (float*)&posZero;
    cout << "Pos Zero: " << *fPosZero << endl;

    // 2. Negative Zero (-0.0)
    // Sign: 1, Exp: 0, Frac: 0
    int negZero = 0b10000000000000000000000000000000;
    float* fNegZero = (float*)&negZero;
    cout << "Neg Zero: " << *fNegZero << endl;
    
    cout << "\n--- INFINITY ---" << endl;

    // 3. Positive Infinity (+inf)
    // Sign: 0, Exp: All 1s (255), Frac: 0
    int posInf = 0b01111111100000000000000000000000;
    float* fPosInf = (float*)&posInf;
    cout << "Pos Inf:  " << *fPosInf << endl;

    // 4. Negative Infinity (-inf)
    // Sign: 1, Exp: All 1s, Frac: 0
    int negInf = 0b11111111100000000000000000000000;
    float* fNegInf = (float*)&negInf;
    cout << "Neg Inf:  " << *fNegInf << endl;

    cout << "\n--- NaNs ---" << endl;

    // 5. Quiet NaN (qNaN) - The Safe One
    // Exp: All 1s, Frac: MSB is 1
    int quietNaN = 0b01111111110000000000000000000000;
    float* fQuietNaN = (float*)&quietNaN;
    cout << "Quiet NaN:    " << *fQuietNaN << endl;

    // 6. Signaling NaN (sNaN) - The Dangerous One
    // Exp: All 1s, Frac: MSB is 0, LSB is 1 (Non-zero)
    // Note: The specific bit pattern for sNaN vs qNaN can vary by CPU (Intel vs ARM),
    // but usually setting the top Mantissa bit to 0 makes it "Signaling".
    int signalNaN = 0b01111111100000000000000000000001;
    float* fSignalNaN = (float*)&signalNaN;
    cout << "Signaling NaN: " << *fSignalNaN << endl;

    cout << "\n--- SUBNORMALS (Tiny) ---" << endl;

    // 7. Smallest Positive Subnormal (2^-149)
    // Exp: 0, Frac: ...001
    int minSub = 0b00000000000000000000000000000001;
    float* fMinSub = (float*)&minSub;
    cout << "Min Subnormal: " << *fMinSub << endl;

    // 8. Largest Subnormal
    // Exp: 0, Frac: All 1s
    int maxSub = 0b00000000011111111111111111111111;
    float* fMaxSub = (float*)&maxSub;
    cout << "Max Subnormal: " << *fMaxSub << endl;

    cout << "\n--- NORMALS (Standard) ---" << endl;

    // 9. Smallest Positive Normal
    // Exp: 1, Frac: 0
    int minNorm = 0b00000000100000000000000000000000;
    float* fMinNorm = (float*)&minNorm;
    cout << "Min Normal: " << *fMinNorm << endl;

    // 10. Largest Finite Number (Max Float)
    // Exp: 254 (Max valid), Frac: All 1s
    int maxFloat = 0b01111111011111111111111111111111;
    float* fMaxFloat = (float*)&maxFloat;
    cout << "Max Float:  " << *fMaxFloat << endl;

    // =========================================================
    // CRASH ZONE: TRIGGERING THE SIGNALING NaN
    // =========================================================
    
    cout << "\n--- PREPARING TO CRASH ---" << endl;

    // Step 1: Tell the CPU to STOP ignoring Invalid Math errors.
    // By default, C++ just turns bad math into "nan" silently.
    // We must enable the "Invalid Operation" trap.
    // (This works on Linux/GCC. Visual Studio uses _controlfp)
    feenableexcept(FE_INVALID); 

    // Step 2: Perform math with the Signaling NaN.
    // Just 'looking' at it (printing) is usually safe.
    // But DOING math with it forces the FPU to process it.
    
    float crashResult = *fSignalNaN + 10.0f;  // <--- CRASH HAPPENS HERE!

    cout << "If you see this, the crash failed: " << crashResult << endl;
    

    return 0;
}
```