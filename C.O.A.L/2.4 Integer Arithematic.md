# Advanced Integer Arithmetic (The "Missing" Manual)

## 1. Bitwise Shifting & Rotating

Shifts are not just for moving bits; they are the "poor man's multiplication/division" and are heavily tested on their flag effects.

### A. Logical vs. Arithmetic Shifts

- **`SHL` (Shift Left) / `SAL` (Shift Arithmetic Left):**
    
    - **Identical!** They are the same machine code.
        
    - Shifts bits left, fills LSB with 0.
        
    - **Effect:** Multiplies by 2.
        
    - **Flag:** CF = The bit shifted out.
        
- **`SHR` (Shift Logical Right):**
    
    - Shifts bits right, **fills MSB with 0**.
        
    - **Effect:** Unsigned division by 2.
        
- **`SAR` (Shift Arithmetic Right):**
    
    - Shifts bits right, **fills MSB with the original Sign Bit** (Sign Extension).
        
    - **Effect:** Signed division by 2.
        
    - **Critical Usage:** Preserves the sign of negative numbers while dividing.
        

**MCQ Trap:** "If AL = 11110000b (-16), what is AL after `SAR AL, 1`?"

- **Answer:** 11111000b (-8).
    
- _Note:_ If you used `SHR`, it would become 01111000b (+120), destroying the signed value.
    

### B. Rotations (`ROL`, `ROR`, `RCL`, `RCR`)

Rotations cycle bits. They are used for encryption or examining bits without destroying data.

- **`ROL` (Rotate Left):** MSB moves to LSB _and_ CF.
    
- **`RCL` (Rotate Carry Left):** 9-bit rotation (8 bits of register + 1 bit of CF). The CF acts as a bridge.
    
    - _Visual:_ [CF] <--- [Register] <--- [CF]
        

## 2. Multiplication (`MUL` vs `IMUL`)

The x86 architecture is weird here: the destination register is **implicit** (hardcoded).

### A. `MUL` (Unsigned)

- **Format:** `MUL source` (Source can be Reg or Mem, _never_ Immediate).
    
- **Implicit logic:**
    
    - `MUL AL` -> `AX = AL * AL` (8-bit * 8-bit = 16-bit result)
        
    - `MUL BX` -> `DX:AX = AX * BX` (16-bit * 16-bit = 32-bit result)
        
    - `MUL EBX` -> `EDX:EAX = EAX * EBX` (32-bit * 32-bit = 64-bit result)
        
- **The "Overflow" Flag (CF/OF):**
    
    - If the upper half of the result (AH, DX, or EDX) is **zero**, `CF=0` and `OF=0`.
        
    - If the upper half is **non-zero**, `CF=1` and `OF=1`.
        
    - _Meaning:_ "Does the result fit in the lower half?"
        

### B. `IMUL` (Signed)

Has three formats, unlike `MUL`.

1. **One Operand:** `IMUL source` (Same implicit behavior as MUL, but signed).
    
2. **Two Operands:** `IMUL Reg, Source` (Reg = Reg * Source).
    
    - _Warning:_ Result is truncated to the size of Reg. Overflow is lost (but signaled by OF/CF).
        
3. **Three Operands:** `IMUL Dest, Source, Immediate` (Dest = Source * Immediate).
    
    - Example: `IMUL eax, ebx, 5`
        

## 3. Division (`DIV` vs `IDIV`) - The Crash Zone

Division is the most dangerous instruction because it causes a **processor exception (crash)** if you mess up.

### A. The Setup (Sign Extension)

Before dividing, you **MUST** prepare the upper register (EDX or DX or AH) because the CPU always divides a _double-width_ number.

- **For `DIV` (Unsigned):** Zero out the upper register.
    
    - `MOV EDX, 0`
        
    - `DIV EBX` ; Divides EDX:EAX by EBX
        
- **For `IDIV` (Signed):** Sign-extend EAX into EDX.
    
    - **Instructions:**
        
        - `CBW` (Convert Byte to Word): AL -> AX
            
        - `CWD` (Convert Word to Double): AX -> DX:AX
            
        - `CDQ` (Convert Double to Quad): EAX -> EDX:EAX
            
    - **Mandatory Step:** If you forget `CDQ` before `IDIV`, EDX might contain garbage, making a huge number, causing an overflow crash.
        

### B. The Results

- **32-bit Div:** `EDX:EAX / Operand` -> Quotient in `EAX`, Remainder in `EDX`.
    
- **16-bit Div:** `DX:AX / Operand` -> Quotient in `AX`, Remainder in `DX`.
    

**Mind-Bending Scenario: Divide Overflow** If the quotient is too large to fit in the destination (EAX), the CPU crashes with "Integer Overflow."

- _Example:_ Dividing `FFFFFFFFh` (in EDX:EAX) by `1`. The result fits, but if you divide a massive 64-bit number by `2`, the result might still exceed 32 bits.
    

## 4. Extended Precision (`ADC` & `SBB`)

How do you add 64-bit numbers on a 32-bit processor? You use the Carry Flag as a bridge.

- **`ADC` (Add with Carry):** `Dest = Dest + Source + CF`.
    
- **`SBB` (Subtract with Borrow):** `Dest = Dest - Source - CF`.
    

**Algorithm for 64-bit Addition:**

1. Add lower 32 bits (`ADD`).
    
2. Add upper 32 bits (`ADC`) to include any carry from the lower half.
    

```
mov edx, 0      ; Clear upper half of sum
mov eax, val1   ; Load lower half
add eax, val2   ; Add lower halves
adc edx, 0      ; Add Carry to upper half (EDX becomes 1 if carry occurred)
```

## 5. Packed Decimal & ASCII (The "Weird" Instructions)

Rarely used in modern code, but often on syllabus.

- **`AAA` (ASCII Adjust after Add):** Fixes result in AL to be a valid unpacked decimal digit (0-9).
    
- **`DAA` (Decimal Adjust after Add):** Adjusts AL after adding two Packed BCD numbers.
    
    - _Packed BCD:_ Stores two digits per byte (e.g., `45h` = 45 decimal).
        
    - If you add `35h + 48h` = `7Dh`. `DAA` converts `7Dh` back to `83h` (correct BCD result).
        

## 6. MCQ Trap Zone

1. **Q: What is the value of `EDX` after `MOV EAX, 10` / `MOV EBX, 5` / `MUL EBX`?**
    
    - **A:** **0**. The result is 50, which fits entirely in `EAX`. `EDX` is the upper half (0).
        
2. **Q: Which instruction sign-extends EAX into EDX:EAX?**
    
    - **A:** `CDQ`. (`CWD` is for AX -> DX:AX).
        
3. **Q: If you want to divide -100 by 5, which sign extension do you use?**
    
    - **A:** `CBW` (if 8-bit) or `CWD`/`CDQ`. You **cannot** just `MOV AH, 0` or `MOV EDX, 0`; that treats the number as positive unsigned!
        
4. **Q: Does `SHL` affect the Sign Flag?**
    
    - **A:** Yes. The Sign Flag is set equal to the new MSB after the shift.