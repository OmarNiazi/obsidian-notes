## 1. RE $\rightarrow$ $\lambda$-NFA (Thompson's Construction)

**Goal:** To convert a regular expression into an NFA that uses $\lambda$-transitions (empty-string transitions).

**Core Rule:** Every "machine" fragment we build must have **exactly one start state** and **exactly one final state**.

---

### ðŸ”¹ Base Cases (The "Atoms")

1. **For a single symbol `a`:**
    
    - Create a start state `(s)` and a final state `(f)`.
        
    - Add one transition: `(s) -a> (f)`
        
2. **For the empty string `$\lambda$`:**
    
    - Create a start state `(s)` and a final state `(f)`.
        
    - Add one transition: `(s) -^> (f)`
        

---

### ðŸ”¹ Combination Rules (The "Glue")

Assume we have the NFA machines for `R` (called `N(R)`) and `S` (called `N(S)`).

1. **For Union (`R | S`):**
    
    - Create a **new start state** `(s_new)` and a **new final state** `(f_new)`.
        
    - Add $\lambda$-transitions from `s_new` to the start states of _both_ `N(R)` and `N(S)`.
        
    - Add $\lambda$-transitions from the final states of _both_ `N(R)` and `N(S)` to `f_new`.
        
2. **For Concatenation (`RS`):**
    
    - The start state of `N(R)` becomes the new overall start state.
        
    - The final state of `N(S)` becomes the new overall final state.
        
    - Add a $\lambda$-transition from the **final state of `N(R)`** to the **start state of `N(S)`**.
        
3. **For Kleene Star (`R*`):**
    
    - Create a **new start state** `(s_new)` and a **new final state** `(f_new)`.
        
    - Add a $\lambda$-transition from `s_new` directly to `f_new` (to skip, i.e., "zero times").
        
    - Add a $\lambda$-transition from `s_new` to the start state of `N(R)` (to enter the loop).
        
    - Add a $\lambda$-transition from the final state of `N(R)` back to the start state of `N(R)` (to repeat the loop).
        
    - Add a $\lambda$-transition from the final state of `N(R)` to `f_new` (to exit the loop).

#### Example
Here are the step-by-step solutions for converting those Regular Expressions to $\lambda$-NFAs, following the algorithm and your notation.

_(Remember, I'll use `+` to mean **Union (OR)** as is common in REs, and `^` for $\lambda$-transitions.)_

---

### 1) RE: `a(ba + a)*`

We build this from the inside out: `b` $\rightarrow$ `a` $\rightarrow$ `ba` $\rightarrow$ `a` $\rightarrow$ `(ba + a)` $\rightarrow$ `(ba + a)*` $\rightarrow$ `a(ba + a)*`

1. **Atoms:** We need four "atom" machines.
    
    - `N(a1)` (for the start): `[1] -a> [2]`
        
    - `N(b)`: `[3] -b> [4]`
        
    - `N(a2)` (for `ba`): `[5] -a> [6]`
        
    - `N(a3)` (for the `+ a`): `[7] -a> [8]`
        
2. **Concatenation `N(ba)`:** Combine `N(b)` and `N(a2)`.
    
    - Glue `[4]` to `[5]`: `[4] -^> [5]`
        
    - This machine `N(ba)` runs from `[3]` to `[6]`.
        
3. **Union `N(ba + a)`:** Combine `N(ba)` (from `[3]`-`[6]`) and `N(a3)` (from `[7]`-`[8]`).
    
    - Create new start `[9]` and final `[10]`.
        
    - `[9] -^> [3]` (Path to `ba`)
        
    - `[9] -^> [7]` (Path to `a`)
        
    - `[6] -^> [10]` (From `ba`)
        
    - `[8] -^> [10]` (From `a`)
        
    - This machine `N(ba + a)` runs from `[9]` to `[10]`.
        
4. **Star `N((ba + a)*)`:** Apply the **Star** rule to the `N(ba + a)` machine.
    
    - Create new start `[11]` and final `[12]`.
        
    - `[11] -^> [12]` (Skip path)
        
    - `[11] -^> [9]` (Enter loop)
        
    - `[10] -^> [9]` (Loop back)
        
    - `[10] -^> [12]` (Exit loop)
        
    - This machine `N((ba + a)*)` runs from `[11]` to `[12]`.
        
5. **Concatenation `N(a(ba + a)*)`:** Combine `N(a1)` and `N((ba + a)*)`.
    
    - Glue `[2]` to `[11]`: `[2] -^> [11]`
        
    - The overall start is `[1]`.
        
    - The overall final is `[12]`.
        

#### âœ… Final NFA for `a(ba + a)*`

- **Start State:** `[1]`
    
- **Final State:** `[+12]`
    
- **Transitions:**
    
    - `[1] -a> [2]`
        
    - `[2] -^> [11]` (Concat glue)
        
    - `[11] -^> [9]` (Star enter)
        
    - `[11] -^> [+12]` (Star skip)
        
    - `[9] -^> [3]` (Union path 1)
        
    - `[3] -b> [4]`
        
    - `[4] -^> [5]`
        
    - `[5] -a> [6]`
        
    - `[6] -^> [10]`
        
    - `[9] -^> [7]` (Union path 2)
        
    - `[7] -a> [8]`
        
    - `[8] -^> [10]`
        
    - `[10] -^> [9]` (Star loop)
        
    - `[10] -^> [+12]` (Star exit)
        

---

### 2) RE: `(a + b)*abb`

We build this in two main parts: `(a + b)*` and `abb`, then concatenate them.

1. **Atoms:**
    
    - `N(a1)` (for star): `[1] -a> [2]`
        
    - `N(b1)` (for star): `[3] -b> [4]`
        
    - `N(a2)` (for `abb`): `[5] -a> [6]`
        
    - `N(b2)` (for `abb`): `[7] -b> [8]`
        
    - `N(b3)` (for `abb`): `[9] -b> [10]`
        
2. **Union `N(a + b)`:** Combine `N(a1)` and `N(b1)`.
    
    - New start `[11]`, new final `[12]`.
        
    - `[11] -^> [1]`
        
    - `[11] -^> [3]`
        
    - `[2] -^> [12]`
        
    - `[4] -^> [12]`
        
3. **Star `N((a + b)*)`:** Apply the **Star** rule to `N(a + b)`.
    
    - New start `[13]`, new final `[14]`.
        
    - `[13] -^> [14]` (Skip)
        
    - `[13] -^> [11]` (Enter)
        
    - `[12] -^> [11]` (Loop)
        
    - `[12] -^> [14]` (Exit)
        
    - This is the first half, `N((a + b)*)`, running from `[13]` to `[14]`.
        
4. **Concatenation `N(abb)`:** Build the second half.
    
    - Concat `N(a2)` and `N(b2)`: `[6] -^> [7]`
        
    - Concat `N(a2b2)` and `N(b3)`: `[8] -^> [9]`
        
    - This is the second half, `N(abb)`, running from `[5]` to `[10]`.
        
5. **Concatenation `N((a + b)*abb)`:** Combine the two halves.
    
    - Glue final of star `[14]` to start of `abb` `[5]`: `[14] -^> [5]`
        
    - Overall start is `[13]`.
        
    - Overall final is `[10]`.
        

#### âœ… Final NFA for `(a + b)*abb`

- **Start State:** `[13]`
    
- **Final State:** `[+10]`
    
- **Transitions:**
    
    - `[13] -^> [14]` (Star skip)
        
    - `[13] -^> [11]` (Star enter)
        
    - `[11] -^> [1]` (Choice a)
        
    - `[1] -a> [2]`
        
    - `[2] -^> [12]`
        
    - `[11] -^> [3]` (Choice b)
        
    - `[3] -b> [4]`
        
    - `[4] -^> [12]`
        
    - `[12] -^> [11]` (Star loop)
        
    - `[12] -^> [14]` (Star exit)
        
    - `[14] -^> [5]` (Concat glue)
        
    - `[5] -a> [6]`
        
    - `[6] -^> [7]`
        
    - `[7] -b> [8]`
        
    - `[8] -^> [9]`
        
    - `[9] -b> [+10]`
        

---

### 3) RE: `a + b + ^`

This is a three-way union: `(a + b) + ^`.

1. **Atoms:**
    
    - `N(a)`: `[1] -a> [2]`
        
    - `N(b)`: `[3] -b> [4]`
        
    - `N(^)` : `[5] -^> [6]`
        
2. **Union `N(a + b)`:** Combine `N(a)` and `N(b)`.
    
    - New start `[7]`, new final `[8]`.
        
    - `[7] -^> [1]`
        
    - `[7] -^> [3]`
        
    - `[2] -^> [8]`
        
    - `[4] -^> [8]`
        
    - This is `N(a + b)`, running from `[7]` to `[8]`.
        
3. **Union `N((a + b) + ^)`:** Combine `N(a + b)` and `N(^)`.
    
    - New start `[9]`, new final `[10]`.
        
    - `[9] -^> [7]` (Path to `a+b`)
        
    - `[9] -^> [5]` (Path to `^`)
        
    - `[8] -^> [10]` (From `a+b`)
        
    - `[6] -^> [10]` (From `^`)
        

#### âœ… Final NFA for `a + b + ^`

- **Start State:** `[9]`
    
- **Final State:** `[+10]`
    
- **Transitions:**
    
    - `[9] -^> [7]` (Path 1)
        
    - `[7] -^> [1]`
        
    - `[1] -a> [2]`
        
    - `[2] -^> [8]`
        
    - `[7] -^> [3]`
        
    - `[3] -b> [4]`
        
    - `[4] -^> [8]`
        
    - `[8] -^> [+10]`
        
    - `[9] -^> [5]` (Path 2)
        
    - `[5] -^> [6]`
        
    - `[6] -^> [+10]`
        

---

### 4) RE: `(ab + aa)*`

This is a star applied to a union of two concatenations.

1. **Atoms:**
    
    - `N(a1)` (for `ab`): `[1] -a> [2]`
        
    - `N(b)` (for `ab`): `[3] -b> [4]`
        
    - `N(a2)` (for `aa`): `[5] -a> [6]`
        
    - `N(a3)` (for `aa`): `[7] -a> [8]`
        
2. **Concatenation `N(ab)`:**
    
    - Glue `[2]` to `[3]`: `[2] -^> [3]`
        
    - This machine `N(ab)` runs from `[1]` to `[4]`.
        
3. **Concatenation `N(aa)`:**
    
    - Glue `[6]` to `[7]`: `[6] -^> [7]`
        
    - This machine `N(aa)` runs from `[5]` to `[8]`.
        
4. **Union `N(ab + aa)`:** Combine `N(ab)` and `N(aa)`.
    
    - New start `[9]`, new final `[10]`.
        
    - `[9] -^> [1]` (Path to `ab`)
        
    - `[9] -^> [5]` (Path to `aa`)
        
    - `[4] -^> [10]` (From `ab`)
        
    - `[8] -^> [10]` (From `aa`)
        
    - This is `N(ab + aa)`, running from `[9]` to `[10]`.
        
5. **Star `N((ab + aa)*)`:** Apply the **Star** rule to `N(ab + aa)`.
    
    - New start `[11]`, new final `[12]`.
        
    - `[11] -^> [12]` (Skip)
        
    - `[11] -^> [9]` (Enter)
        
    - `[10] -^> [9]` (Loop)
        
    - `[10] -^> [12]` (Exit)
        

#### âœ… Final NFA for `(ab + aa)*`

- **Start State:** `[11]`
    
- **Final State:** `[+12]`
    
- **Transitions:**
    
    - `[11] -^> [+12]` (Star skip)
        
    - `[11] -^> [9]` (Star enter)
        
    - `[9] -^> [1]` (Union path 1)
        
    - `[1] -a> [2]`
        
    - `[2] -^> [3]`
        
    - `[3] -b> [4]`
        
    - `[4] -^> [10]`
        
    - `[9] -^> [5]` (Union path 2)
        
    - `[5] -a> [6]`
        
    - `[6] -^> [7]`
        
    - `[7] -a> [8]`
        
    - `[8] -^> [10]`
        
    - `[10] -^> [9]` (Star loop)
        
    - `[10] -^> [+12]` (Star exit)