## 1. RE $\rightarrow$ $\lambda$-NFA (Thompson's Construction)

**Goal:** To convert a regular expression into an NFA that uses $\lambda$-transitions (empty-string transitions).

**Core Rule:** Every "machine" fragment we build must have **exactly one start state** and **exactly one final state**.

---

### ðŸ”¹ Base Cases (The "Atoms")

1. **For a single symbol `a`:**
    
    - Create a start state `(s)` and a final state `(f)`.
        
    - Add one transition: `(s) -a> (f)`
        
2. **For the empty string `$\lambda$`:**
    
    - Create a start state `(s)` and a final state `(f)`.
        
    - Add one transition: `(s) -^> (f)`
        

---

### ðŸ”¹ Combination Rules (The "Glue")

Assume we have the NFA machines for `R` (called `N(R)`) and `S` (called `N(S)`).

1. **For Union (`R | S`):**
    
    - Create a **new start state** `(s_new)` and a **new final state** `(f_new)`.
        
    - Add $\lambda$-transitions from `s_new` to the start states of _both_ `N(R)` and `N(S)`.
        
    - Add $\lambda$-transitions from the final states of _both_ `N(R)` and `N(S)` to `f_new`.
        
2. **For Concatenation (`RS`):**
    
    - The start state of `N(R)` becomes the new overall start state.
        
    - The final state of `N(S)` becomes the new overall final state.
        
    - Add a $\lambda$-transition from the **final state of `N(R)`** to the **start state of `N(S)`**.
        
3. **For Kleene Star (`R*`):**
    
    - Create a **new start state** `(s_new)` and a **new final state** `(f_new)`.
        
    - Add a $\lambda$-transition from `s_new` directly to `f_new` (to skip, i.e., "zero times").
        
    - Add a $\lambda$-transition from `s_new` to the start state of `N(R)` (to enter the loop).
        
    - Add a $\lambda$-transition from the final state of `N(R)` back to the start state of `N(R)` (to repeat the loop).
        
    - Add a $\lambda$-transition from the final state of `N(R)` to `f_new` (to exit the loop).

