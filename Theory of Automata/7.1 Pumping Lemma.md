## Non-Regular Languages
**DEFINITION:** A language that cannot be defined by a regular expression is called a **non-regular language**.

**Key Properties:**
- By Kleene's theorem, a non-regular language also cannot be accepted by any FA or TG
- All languages are either regular or non-regular; none are both
- These are languages we can describe in English but cannot define with an FA
---
#### Why Some Languages Can't Be Regular
Up until now, we've been able to define many languages using FAs and regular expressions. These languages typically have simple structures:

- Languages with required substrings
- Languages that forbid certain substrings
- Languages that begin or end with specific patterns
- Languages with even/odd properties
But now we encounter fundamentally different forms like **PALINDROME** or **PRIME** (words $a^p$ where $p$ is prime). These require more powerful machines because they need to "remember" or "count" unbounded amounts of information.

**EXAMPLE:**  $L = {a^n b^n}$
**Language definition:** $L = {\Lambda, ab, aabb, aaabbb, aaaabbbb, \ldots}$

This can be written compactly as $L = {a^n b^n \text{ for } n = 0, 1, 2, 3, \ldots}$ or simply $L = {a^n b^n}$.

**Important distinction:** While $L$ is a subset of the regular language $a^nb^n$, the language $a^nb^n$ also includes strings like "aab" and "bb" that are NOT in $L$. The requirement that the number of a's must exactly equal the number of b's makes all the difference.
-- -
#### The Proof by Contradiction (Intuitive Version)
**Setup:** Suppose (for contradiction) that $L = {a^n b^n}$ were regular. Then some FA with, say, 95 states must accept it.

**The argument:**

1. This FA must accept $a^{96}b^{96}$
2. When processing the first 96 a's, the path through the machine cannot visit a new state for each letter (only 95 states exist)
3. Therefore, the path must **revisit some state** - creating a **circuit** (loop)

**The key insight:** Let's say the circuit has 7 states in it.

- The input $a^{96}b^{96}$ traces a path that loops around this circuit some number of times, then branches onto the "b-road" and reaches a final state
- But now consider $a^{96+7}b^{96}$ (adding 7 more a's)
- This would loop around the circuit **one extra time**, then take the exact same b-road to the same final state
- This means $a^{103}b^{96}$ would also be accepted

**The contradiction:** But $a^{103}b^{96}$ is NOT in $L = {a^n b^n}$ since $103 \neq 96$.
**Conclusion:** No such FA can exist. Therefore, $L$ is non-regular.
-- -
### The General Strategy for the Proof by Contradiction

This proof strategy works for any non-regular language:

1. Choose a word in $L$ that's large enough so its path through any hypothetical FA must contain a circuit
2. Once we find a path with a circuit that reaches a final state, consider what happens if we loop around the circuit one extra time
3. The new path leads to the same final state but corresponds to a different input string
4. If that new string is NOT in $L$, we have a contradiction

This idea is called the **pumping lemma** (discovered by Bar-Hillel, Perles, and Shamir in 1961).

**Why "pumping"?** We pump more letters into the middle of words.

**Why "lemma"?** It's a tool used to prove other results (that specific languages are non-regular).

---

## Theorem 13: The Pumping Lemma (First Version)

**THEOREM 13:** Let $L$ be any regular language that has infinitely many words. Then there exist some three strings $x$, $y$, and $z$ (where $y$ is not the null string) such that all the strings of the form $$xy^n z \text{ for } n = 1, 2, 3, \ldots$$ are words in $L$.

---

#### Proof of Theorem 13

**Given:** $L$ is regular, so there exists an FA that accepts exactly the words in $L$.

**Construction:** Let $w$ be some word in $L$ that has more letters than there are states in the FA.

**Why the circuit exists:** When $w$ generates a path through the machine, the path cannot visit a new state for each letter read (pigeonhole principle). Therefore, the path must revisit some state, creating a circuit.

**Breaking $w$ into three parts:**

1. **Part 1 ($x$):** All letters of $w$ from the start up to the first state that is revisited
    
    - Note: $x$ may be $\Lambda$ if the path revisits the start state immediately
2. **Part 2 ($y$):** The substring that travels around the circuit, coming back to the same state
    
    - Cannot be $\Lambda$ because there must be a circuit
    - Contains letters for exactly one loop around the circuit
3. **Part 3 ($z$):** The rest of $w$ after the circuit
    
    - Could be $\Lambda$
    - May loop around other circuits (behavior is arbitrary)

We have $w = xyz$, and $w$ is accepted by the FA.

---

#### Why Pumping Works

**Consider $xyyz$:**

- Follow the path for $x$ to reach the circuit's starting state
- Input $y$ once → loop back to the same state
- Input $y$ again → loop back to the same state again
- Follow the path for $z$ → reach the same final state as $w$

Therefore $xyyz \in L$.

**The general result:** By the same reasoning, $xyyyz$, $xyyyyz$, ... must all be in $L$.

In other words, $L$ must contain all strings of the form $xy^n z$ for $n = 1, 2, 3, \ldots$

---

#### Example: Applying Theorem 13

Consider this FA (6 states) accepting an infinite language:

**Word:** $w = bbbababa$

**Decomposition:**

- **$x$-part:** Goes from start state to first circuit → substring "$b$"
- **$y$-part:** Goes around circuit (states 2, 3, 5) → substring "$bba$"
- **$z$-part:** Remainder → substring "$baba$"

**Testing:** Does $xyyz = (b)(bba)(bba)(baba)$ get accepted?

- This string loops twice around the circuit and is accepted ✓
- Same for $xyyyz$, $xyyyyz$, and generally $xy^n z$ for all $n \geq 1$

---

## Using Theorem 13 to Prove Non-Regularity

**Goal:** Show $L = {a^n b^n}$ is not regular using Theorem 13.

**Proof by contradiction:**

**Assume:** $L$ is regular.

**Then:** By Theorem 13, there must exist strings $x$, $y$, $z$ such that all words of the form $xy^n z$ are in $L$.

**Analysis:** A typical word in $L$ looks like $\underbrace{aaa\ldots aaa}_{n \text{ a's}}\underbrace{bbb\ldots bbb}_{n \text{ b's}}$

How can we break this into $x$, $y$, $z$?

**Case 1:** If $y$ contains only a's

- Then $xyyz$ has more a's than b's
- Not allowed in $L$ ✗

**Case 2:** If $y$ contains only b's

- Then $xyyz$ has more b's than a's
- Not allowed in $L$ ✗

**Case 3:** If $y$ contains both a's and b's

- Then $y$ contains the substring "$ab$"
- So $xyyz$ contains at least two occurrences of "$ab$"
- But every word in $L$ has exactly one substring "$ab$"
- Therefore $xyyz \notin L$ ✗

**Conclusion:** The pumping lemma cannot apply to $L$, so $L$ is not regular.

---

#### Practice Examples

**EQUAL:** The language of all words over $\Sigma = {a, b}$ with the same total number of a's and b's.

$\text{EQUAL} = {\Lambda, ab, ba, aabb, abab, abba, baab, baba, bbaa, aaabbb, \ldots}$

**Challenge:** Show EQUAL is not regular using the pumping lemma.

**Language $L = {a^n ba^n}$:** The language ${b, aba, aabaa, aaabaaaa, \ldots}$

**Challenge:** Show this is not regular.

---

## Theorem 14: The Pumping Lemma (Second Version)

**THEOREM 14:** Let $L$ be an infinite language accepted by a finite automaton with $N$ states. Then, for all words $w$ in $L$ that have more than $N$ letters, there are strings $x$, $y$, and $z$, where:

- $y$ is not null
- $\text{length}(x) + \text{length}(y) \leq N$

such that $w = xyz$ and all strings of the form $xy^n z$ for $n = 1, 2, 3, \ldots$ are in $L$.

---

#### Key Difference from Theorem 13

This is another version of the pumping lemma with the same core idea. The crucial addition is the **length constraint:**

$$\text{length}(x) + \text{length}(y) \leq N$$

**Why this matters:** This tells us exactly WHERE in the word the pumpable part must occur - specifically, within the first $N$ letters. This constraint is powerful for proving certain languages non-regular when Theorem 13 alone doesn't suffice.

---

## Proving PALINDROME is Non-Regular

**Language:** PALINDROME = all words that read the same forwards and backwards

**Why Theorem 13 fails here:**

Consider $x = a$, $y = b$, $z = a$. Then all strings $xy^n z = ab^n a$ are palindromes! This satisfies Theorem 13 without contradiction.

**Using Theorem 14 (the stronger version):**

**Setup:** Suppose (for contradiction) PALINDROME were regular. Let's say some FA with 77 states accepts it.

**Choose:** Consider the palindrome $w = a^{80}ba^{80}$ (which must be accepted).

**Apply Theorem 14:** Since $w$ has more than 77 letters, we can break $w = xyz$ where:

- $y \neq \Lambda$
- $\text{length}(x) + \text{length}(y) \leq 77$

**Key observation:** The first 77 letters of $w$ are all a's!

Therefore, both $x$ and $y$ must consist entirely of a's.

**The contradiction:**

- When we form $xyyz$, we're adding more a's to the **front** of $w$
- But we're NOT adding more a's to the **back** of $w$
- Thus $xyyz$ has the form $a^{(\text{more than } 80)}ba^{80}$
- This is clearly NOT a palindrome

**But** Theorem 14 says $xyyz$ must be in PALINDROME - contradiction!

**Conclusion:** PALINDROME is NOT regular.

---

#### Why the Length Constraint Was Essential

Without knowing that $\text{length}(x) + \text{length}(y) \leq 77$, we couldn't guarantee that $x$ and $y$ both occur before the middle "$b$". The pumping could have occurred anywhere in the word, potentially maintaining the palindrome property.

The length constraint **forces** the pumpable portion to be in a specific location where pumping will break the palindrome structure.

---

## Example: PRIME is Non-Regular

**Language:** $\text{PRIME} = {a^p \mid p \text{ is prime}}$

**Recall:** A prime is a positive integer greater than 1 whose only positive divisors are 1 and itself: 2, 3, 5, 7, 11, 13, ...

**Expanded form:** $\text{PRIME} = {aa, aaa, aaaaa, aaaaaaa, aaaaaaaaaaa, \ldots}$

**Challenge:** Can you show PRIME is non-regular using the pumping lemma?

**Hint:** Consider what happens when you choose a prime $p > N$ and pump the word $a^p$. Think about how pumping creates words whose lengths follow an arithmetic progression, and how this relates to divisibility.

---

## Summary: The Pumping Lemma Strategy

**When to use pumping lemma:** To prove a language is NOT regular.

**General approach:**

1. **Assume** the language $L$ is regular
2. **Invoke** the pumping lemma (Theorem 13 or 14 depending on the language)
3. **Choose** a word $w \in L$ (often parametric, like $a^n b^n$)
4. **Decompose** $w = xyz$ according to pumping lemma constraints
5. **Consider** all possible cases for what $y$ could be
6. **Pump** to create $xy^2z$ (or $xy^0z = xz$, or other values of $n$)
7. **Show** the pumped string is NOT in $L$
8. **Conclude** contradiction → $L$ is not regular

**Pro tip:** Theorem 14's length constraint is often crucial when the language has a "symmetry" or "matching" property where you need to know WHERE the pumping occurs.

---

## Key Insights

**The fundamental limitation of FAs:** Finite automata have finite memory (only the current state). They cannot "count" or "remember" unbounded amounts of information. Any language that requires matching, balancing, or counting arbitrary amounts inherently cannot be regular.

**Examples of non-regular languages:**

- ${a^n b^n}$ - requires counting to match
- PALINDROME - requires remembering the entire first half
- PRIME - requires arithmetic/divisibility checking
- EQUAL - requires counting both symbols

**The power hierarchy:** These languages need more powerful computational models (like pushdown automata or Turing machines) that have unbounded memory capacity.

**Intuition:** If you can't build an FA with a fixed number of states to recognize a language (no matter how many states you try), it's because the language requires tracking information that grows with input size - something finite memory cannot do.