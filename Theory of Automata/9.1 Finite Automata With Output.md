# Mealy and Moore Machines

## Introduction

### What Are These Exactly?

**Simple Definition:**
Mealy and Moore machines are like regular finite automata but supercharged. They can produce output. Instead of just accepting or rejecting strings, they generate a sequence of outputs as they process input symbols. Think of them as machines that don't just say "yes" or "no" at the end. They actively respond to each input they receive.

**Formal Definition:**
Mealy and Moore machines are **finite state machines (FSMs)** that extend the basic finite automaton model by incorporating an output function. While standard finite automata are recognizers that classify strings as accepted or rejected, Mealy and Moore machines are **transducers that map input sequences to output sequences**. The key distinction between the two lies in their output mechanism: Mealy machines produce output based on the current state and input symbol, while Moore machines generate output based solely on the current state.

### What Problem Do They Solve?

**Beyond Recognition:**
Standard finite automata (FAs) and transition graphs (TGs) are limited to recognition tasksâ€”they can only tell you whether a string belongs to a language or not. They're binary decision makers with no middle ground.

Mealy and Moore machines solve a fundamentally different problem: **transduction**. They transform input sequences into output sequences, enabling applications like:
- Circuit design and digital systems (e.g., sequence detectors, counters)
- Protocol conversion and data encoding/decoding
- Control systems that need to respond to inputs with specific actions
- Pattern recognition with feedback (not just accept/reject, but "what pattern did we see?")

In essence, while FAs answer "Is this string valid?", Mealy and Moore machines answer "Given this input sequence, what should the output sequence be?"

---
## Moore Machine

### Formal Definition

A **Moore machine** is a collection of five components:

1. **A finite set of states** $q_0, q_1, q_2, \ldots$ where $q_0$ is designated as the start state.

2. **An input alphabet** $\Sigma$ for forming the input string:
   $$\Sigma = \{a, b, c, \ldots\}$$

3. **An output alphabet** $\Gamma$ of possible output characters:
   $$\Gamma = \{x, y, z, \ldots\}$$

4. **A transition table** that shows for *each* state and *each* input letter what state is reached next.

5. **An output table** that shows what character from $\Gamma$ is printed by each state that is entered.

> **Key Insight:** In a Moore machine, the output depends **only on the current state**, not on the input symbol. The output is produced when entering a state.

---

### Example: Moore Machine

Consider the following Moore machine:

**Input alphabet:** $\Sigma = \{a, b\}$  
**Output alphabet:** $\Gamma = \{0, 1\}$  
**States:** $q_0, q_1, q_2, q_3$ (where $q_0$ is the start state)

#### Transition and Output Table

| Old State | Output | After Input $a$ | After Input $b$ |
| --------- | ------ | --------------- | --------------- |
| $-$ $q_0$ | 1      | $q_1$           | $q_3$           |
| $q_1$     | 0      | $q_3$           | $q_1$           |
| $q_2$     | 0      | $q_0$           | $q_3$           |
| $q_3$     | 1      | $q_3$           | $q_2$           |



#### State Diagram

The pictorial representation of this Moore machine is:
```tikz
	\begin{document} 
	\begin{tikzpicture}[>=stealth, node distance=3cm, on grid, auto]
	% Define states with outputs
	\node[state, initial] (q0) {$\begin{array}{c} q_0 \\ / \\ 1 \end{array}$}; 
	\node[state] (q1) [above right=of q0] {$\begin{array}{c} q_1 \\ / \\ 0 \end{array}$}; 
	\node[state] (q3) [below right=of q0] {$\begin{array}{c} q_3 \\ / \\ 1 \end{array}$}; 
	\node[state] (q2) [below left=of q3] {$\begin{array}{c} q_2 \\ / \\ 0 \end{array}$};
	
	\end{tikzpicture} 
	\end{document}


```
