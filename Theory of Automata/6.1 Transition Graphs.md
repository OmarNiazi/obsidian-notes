
**DEFINITION:** A transition graph is a collection of three things:
1. A finite set of states, at least one of which is designated as the **start state (-)**, and some (maybe none) of which are designated as **final states (+)**.
2. An alphabet $\Sigma$ of possible input letters from which input strings are formed.
3. A finite set of **transitions** (edge labels) that show how to go from some states to some others, based on reading **specified substrings** of input letters (possibly even the null string $\Lambda$).

**READ:** [[Introduction To Computer Theory.pdf#page=93|Definition and properties of TGs]]
- - -
#### Why Transition Graphs?
The whole idea behind TGs comes from **relaxing the restrictions** that FAs impose on us. Remember how FAs can only read one letter at a time? Well, what if we want to read multiple letters at once, or even no letters at all (free transitions)? That's where TGs come in.
Think of it this way: if you have a language that only accepts the word "baa", you need multiple states in an FA to handle each letter individually. But with a TG, you can have a single edge labeled "baa" that takes you directly from start to final state. It's like taking a shortcut.

**The key insight:** Sometimes it's more natural and efficient to process chunks of input rather than individual letters.
- -  -
#### How TGs Differ from FAs
**Edge Labels:**
- **FA:** Each edge labeled with exactly one letter
- **TG:** Each edge can be labeled with any string of letters (including empty string $\Lambda$)
**State Requirements:**
- **FA:** Must have exactly one outgoing edge for each letter from every state
- **TG:** States can have any number of outgoing edges (even zero)
**Path Determination:**
- **FA:** Given an input, there's exactly one path through the machine
- **TG:** Given an input, there might be multiple ways to trace through the machine
**NOTE:** Every FA is automatically a TG, but not every TG can be an FA.
---
#### The Crash Concept
Here's something new that doesn't happen in FAs: **crashing**.
**DEFINITION:** When an input string that has NOT been completely read reaches a state (final or otherwise) that it cannot leave because there is no outgoing edge that it may follow, we say that the input (or the machine) **crashes** at that state.

This means there are now **two ways** an input can be rejected:
1. **Peaceful rejection:** Input is fully processed but ends in a non-final state
2. **Crash rejection:** Input cannot be fully processed due to lack of valid transitions
#### The Choice Problem and Non-determinism

Consider this scenario: you have input "baa" and your machine has edges labeled "b" and "ba" from the start state. Which do you choose?
- If you read "b" first, then "aa", you might accept
- If you read "ba" first, then "a", you might reject or crash
This introduces **non-determinism** - the machine doesn't uniquely determine its own path. Human choice becomes a factor.

**New Acceptance Rule:** A string is accepted if there exists **some way** it could be processed so as to arrive at a final state.

This is fundamentally different from FAs where there's only one possible path for any input.
- - -
#### Lambda Transitions (Free Moves)
One of the coolest features of TGs is the $\Lambda$-transition - an edge you can traverse without consuming any input letters. It's like getting a "free move" in a board game.
**Why are they useful?**
- Allow multiple start states to be equivalent to single start state designs
- Enable more flexible machine architectures
- Can simplify complex transition structures

**Example:** A word like "b" might take a $\Lambda$-edge to get positioned correctly, then use the "b" to reach the final state.
- - -
#### Multiple Start States
Unlike FAs, TGs can have multiple start states. This doesn't give extra power (you can always convert to single start state using $\Lambda$-transitions), but it can make designs cleaner and more intuitive.
- - -
- - -
**NEXT:**  [[6.2 Generalized TGs]]



  