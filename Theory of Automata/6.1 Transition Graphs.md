
**DEFINITION:** A transition graph is a collection of three things:
1. A finite set of states, at least one of which is designated as the **start state (-)**, and some (maybe none) of which are designated as **final states (+)**.
2. An alphabet $\Sigma$ of possible input letters from which input strings are formed.
3. A finite set of **transitions** (edge labels) that show how to go from some states to some others, based on reading **specified substrings** of input letters (possibly even the null string $\Lambda$).

**READ:** [[Introduction To Computer Theory.pdf#page=93|Definition and properties of TGs]]
- - -
#### Why Transition Graphs?
The whole idea behind TGs comes from **relaxing the restrictions** that FAs impose on us. Remember how FAs can only read one letter at a time? Well, what if we want to read multiple letters at once, or even no letters at all (free transitions)? That's where TGs come in.
Think of it this way: if you have a language that only accepts the word "baa", you need multiple states in an FA to handle each letter individually. But with a TG, you can have a single edge labeled "baa" that takes you directly from start to final state. It's like taking a shortcut.

**The key insight:** Sometimes it's more natural and efficient to process chunks of input rather than individual letters.
- -  -
#### How TGs Differ from FAs
**Edge Labels:**
- **FA:** Each edge labeled with exactly one letter
- **TG:** Each edge can be labeled with any string of letters (including empty string $\Lambda$)
**State Requirements:**
- **FA:** Must have exactly one outgoing edge for each letter from every state
- **TG:** States can have any number of outgoing edges (even zero)
**Path Determination:**
- **FA:** Given an input, there's exactly one path through the machine
- **TG:** Given an input, there might be multiple ways to trace through the machine
**NOTE:** Every FA is automatically a TG, but not every TG can be an FA.
---
#### The Crash Concept
Here's something new that doesn't happen in FAs: **crashing**.
**DEFINITION:** When an input string that has NOT been completely read reaches a state (final or otherwise) that it cannot leave because there is no outgoing edge that it may follow, we say that the input (or the machine) **crashes** at that state.

This means there are now **two ways** an input can be rejected:
1. **Peaceful rejection:** Input is fully processed but ends in a non-final state
2. **Crash rejection:** Input cannot be fully processed due to lack of valid transitions
#### The Choice Problem and Non-determinism
Consider this scenario: you have input "baa" and your machine has edges labeled "b" and "ba" from the start state. Which do you choose?


- If you read "b" first, then "aa", you might accept

- If you read "ba" first, then "a", you might reject or crash

  

This introduces **non-determinism** - the machine doesn't uniquely determine its own path. Human choice becomes a factor.

  

**New Acceptance Rule:** A string is accepted if there exists **some way** it could be processed so as to arrive at a final state.

  

This is fundamentally different from FAs where there's only one possible path for any input.

  

---

  

#### Lambda Transitions (Free Moves)

  

One of the coolest features of TGs is the $\Lambda$-transition - an edge you can traverse without consuming any input letters. It's like getting a "free move" in a board game.

  

**Why are they useful?**

- Allow multiple start states to be equivalent to single start state designs

- Enable more flexible machine architectures

- Can simplify complex transition structures

  

**Example:** A word like "b" might take a $\Lambda$-edge to get positioned correctly, then use the "b" to reach the final state.

  

---

  

#### Practical Examples and Languages

  

**EVEN-EVEN Language:**

This TG recognizes strings with an even number of a's and an even number of b's. It uses a clever two-state design:

- **Balanced state:** Even count of both letters

- **Unbalanced state:** Odd count of both letters

- Reading matched pairs (aa, bb) keeps you balanced

- Reading unmatched pairs (ab, ba) flips your state

  

**Words ending in 'b':**

Language: $(a + b)^*b$

- Stay in start state reading any letters

- Use the final 'b' to jump to accept state

- If you jump too early, you crash when trying to read more letters

  

---

  

#### Multiple Start States

  

Unlike FAs, TGs can have multiple start states. This doesn't give extra power (you can always convert to single start state using $\Lambda$-transitions), but it can make designs cleaner and more intuitive.

  

---

  

# Generalized Transition Graphs (GTG)

  

**DEFINITION:** A generalized transition graph is a collection of three things:

1. A finite set of states, of which at least one is a **start state** and some (maybe none) are **final states**.

2. An alphabet $\Sigma$ of input letters.

3. Directed edges connecting some pairs of states, each labeled with a **regular expression**.

  

**The big difference:** Instead of labeling edges with specific strings, we label them with entire regular expressions.

  

---

  

#### Why GTGs Matter

  

GTGs represent the ultimate generalization of our machine concept. Instead of saying "read exactly this string," we can say "read any string that matches this pattern."

  

**Example:** An edge labeled $(ba + a)^*$ means you can traverse it by reading any string generated by that regular expression - "ba", "a", "baa", "aba", "", etc.

  

**Key insight:** There's a beautiful equivalence between Kleene star closure in regular expressions and loops in transition graphs. A loop that you can traverse zero or more times is essentially the same as a starred expression where you can choose the $\Lambda$ option.

  

---

  

#### The Power of Regular Expression Labels

  

Consider recognizing "all strings without a double b." In a regular TG, this might require multiple states and careful edge management. In a GTG, you might handle most of the complexity in the regular expression on a single edge.

  

This makes GTGs incredibly powerful for compact representation of complex languages, though they can be harder to trace through by hand.

  

---

  

#### Non-determinism in Full Force

  

GTGs exhibit non-determinism in two ways:

1. **Path choice:** Multiple ways to traverse the machine

2. **Pattern matching:** Multiple ways a string might match a regular expression

  

This double layer of non-determinism makes GTGs very flexible but also means that acceptance requires even more careful consideration of "does there exist some way..."

  

---

  

#### The Hierarchy

  

Understanding the relationship:

- **FA ⊆ TG ⊆ GTG**

- Every FA is a TG (just restrict edge labels to single letters)

- Every TG is a GTG (just treat string labels as trivial regular expressions)

- The reverse inclusions are not true

  

---
**NOTE:** The real power of these concepts becomes apparent when you start converting between different representations and proving language equivalences. Practice with concrete examples is essential - the theory only makes sense when you can trace through actual machines with actual inputs.

  