The Recursive Definition is characteristically a **3-step process**. It is as follows:

1) First, we specify few basic objects in the set. This is known as the **Base Case**. 
2) Second, we give rules for constructing more objects in the set from the base ones. This is called the **Recursive Case.**
3) Third, we declare that no objects except those constructed in this way are allowed in the set. This is called the **Closure.**
- - -
**e.g1.** Suppose we are trying to define a set of integers that are all even and though there are several ways to define that set (e.g. EVEN is the set of all 2n where n = 1 2 3 4...) but we are trying to prove this by **recursive definition**.  Here is how it will go:

>**RULE 1:** Base case -> 2 is in the EVEN set
  **RULE 2**: If x is in even, then so is x + 2 and x - 2. 
  **RULE 3:** The only elements in the EVEN set are those that can be produced from the above two rules.

The book delves into why this process of defining a set is unpopular; it is hard and lengthy to prove, as you can read [[Introduction To Computer Theory.pdf#page=35|here]]. Regardless, since this subject deals with everything a computer can do, no matter the "efficiency", we will adhere to this method of construction.

**e.g2.** We can define a set that constitutes all possible valid arithmetic expressions. 

>**RULE 1:** Any number (positive, negative, or zero) is in the set AE (Arithmetic Expressions)
  **RULE 2:** If x is in AE, then so are (x) and -(x).
  **RULE 3:** If x and y are in AE, then so are 
- x + y
- x - y
- x * y
- x / y
- x ** y
[[Introduction To Computer Theory.pdf#page=39|this page]] further explores this example with several theorems.
- - -
### Soundness and Completeness
Any set must be **sound** i.e. it must generate only and only the entities that contain the defining characteristic of the desired set. 
Any set must also be complete i.e. generate all possible entities that contain the defining characteristic of the set/the definition should suffice to generate an unlimited amount of entities.
- - -
- - -
**NOTE:** This definition supplements the proof by constructive algorithm we discussed in the previous chapter.
**NEXT:** [[3.p Examples & Problems]]
- - -
